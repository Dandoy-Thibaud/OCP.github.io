<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[OCP_vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>OCP_vault</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 23 Jul 2024 10:02:32 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 23 Jul 2024 10:02:29 GMT</pubDate><copyright><![CDATA[Thibaud DANDOY]]></copyright><ttl>60</ttl><dc:creator>Thibaud DANDOY</dc:creator><item><title><![CDATA[Chapter 5]]></title><description><![CDATA[ 
 <br><br><br><br>A method follows this nomenclature:<br>public final void example(int a) throws ExampleException {
	//Body
}
Copy<br>The declaration above has the following components:<br>
<br>public is the access modifier.
<br>optional is an optional modifier.
<br>void is the return type.
<br>example is the method name.
<br>(int a) is the List of parameters. They require parentheses (()).
<br>throws ExampleException is an optional Exception.
<br>To go further...
If you need a reminder of what an access modifier, the types of return and the naming convention of methods and variables, head over to <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.
<br>Here is a quick recap of the optional and required parts of a method declaration.<br><br>Calling this method would simply be done by using the method signature,<br><br>An access modifier determines what classes a method can be accessed from.<br>
<br>private means that the method can only be called within the same class.
<br>Package access means that the method can only be called within the same package.

<br>Be careful, as this option is the default and requires you to omit the keyword.


<br>protected means that the method can only be called within the same package or subclass.
<br>public means that the method can be called from anywhere.
<br>To go further...
We'll see more about other uses of access modifiers later in <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>.
<br>For example:<br>public class example {
	public void a() {}
	default void b() {} // DOES NOT COMPILE
	void public c() {} // DOES NOT COMPILE
	void d() {}
}
Copy<br>Only the methods on line 2 and 5 will compile, because default is not a keyword, and public doesn't come after word.<br>Tricks ahead!
The exam makers like sneaking in these kinds of tricks. Be careful with the order of elements!
<br><br><br><br><br><br><br>]]></description><link>ocp/chapter-5-methods.html</link><guid isPermaLink="false">OCP/CHAPTER 5 - METHODS.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Wed, 10 Jul 2024 09:47:35 GMT</pubDate></item><item><title><![CDATA[Chapter 14]]></title><description><![CDATA[ 
 <br><br>I/O means input/output, or how to manage system files outside of a java application. This chapter focuses on I/O and NIO.2, or non blocking I/O.<br>Good practice !
It is good practice to use NIO.2 where you can, but in practice, both are still widely in use.
<br><br><br>There are two important components in the file system: files and directories:<br>
<br>A file is a storage device that holds data.
<br>A directory is a location that contains files as well as other directories.
<br>Note
Java often treats directories as files, so much so that some methods work on both files and directories alike.
<br>To interact with files, you need to connect with the file system.<br>Note
The file system operates very differently depending on the operating system.
Inexam
However, you don't need to know the difference for the exam, just to know the how to interact with the Java API.

<br>The root directory is a special directory in that it is the topmost directory in the file system. All files and directories will directly inherit from it.<br>
<br>On Windows, it is denoted with a drive letter such as C:\
<br>On Linux, it is denoted with a single forward slash such as /.
<br>A path is a representation of a file or directory within the file system. Each file system defines its own path separator character that is used between directories entries.<br>
The value to the left of a separator is the parent of the value to the right of the separator.<br>For example:<br>/user/home/example.txt
Copy<br>This means that the file example.txt is inside the home directory, which is inside the user directory.<br>Required Knowledge
As previously stated, different operating systems use different path separator characters.<br>
Java offers a system property to retrieve the local separator character for the current environment:
System.out.println(System.getProperty("file.separator"));
Copy
<br>There are two different kinds of paths that can be used for pinpointing a file: a absolute path and an relative path:<br>
<br>The absolute path of a file is the path that starts at the root directory and finishes at the file.
<br>The relative path of a file is the path that starts at the current working directory and finishes at the file.
<br>For the following file system:<br>C:
├─ App
│  ├─ Animals
│  │  ├─ Bear.java
│  │  └─ Bear.class
│  └─ Employees
│     └─ java.exe
└─ Zoo
   └─ info.txt
Copy<br>
<br>The absolute path for Bear.java is C:\App\Animals\Bear.java
<br>The relative path for Bear.java:

<br>When the working directory is Animals is Bear.java
<br>When the working directory is Employees is ..\Animals\Bear.java
<br>When the working directory is Zoo is ..\App\Animals\Bear.java


<br>Required Knowledge
Determining if a path is relative or absolute is system dependent.
Inexam
We will adopt the following conventions to match the exam questions:

<br>If a path starts with a forward slash, it is absolute, with / as the root directory, such as /example/img.jpg
<br>If a path starts with a drive letter (c:,d:, etc...), it is absolute, with the drive letter as the root directory, such as C:/example/img.jpg
<br>Otherwise, it is a relative path, such as example/img.jpg


]]></description><link>ocp/chapter-14-io.html</link><guid isPermaLink="false">OCP/CHAPTER 14 - IO.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Fri, 19 Jul 2024 12:11:00 GMT</pubDate></item><item><title><![CDATA[Backend]]></title><description><![CDATA[ 
 <br><br><br>Définition: Language orienté objet.<br>
Exécuté sur une JVM[¹] qui peut être tournée sur n'importe quelle machine.<br>
La gestion de la mémoire est gérée par la JVM, dans la memory heap.<br>
JVM's configuration is done with Xmx and Xms.<br><br><br>
<br>Set

<br><a data-tooltip-position="top" aria-label="https://www.w3schools.com/java/java_hashset.asp" rel="noopener" class="external-link" href="https://www.w3schools.com/java/java_hashset.asp" target="_blank">HashSet</a>
<br><a data-tooltip-position="top" aria-label="https://www.baeldung.com/java-tree-set" rel="noopener" class="external-link" href="https://www.baeldung.com/java-tree-set" target="_blank">TreeSet</a>


<br>List

<br><a data-tooltip-position="top" aria-label="https://www.w3schools.com/java/java_arraylist.asp" rel="noopener" class="external-link" href="https://www.w3schools.com/java/java_arraylist.asp" target="_blank">ArrayList</a>
<br><a data-tooltip-position="top" aria-label="https://www.w3schools.com/java/java_linkedlist.asp" rel="noopener" class="external-link" href="https://www.w3schools.com/java/java_linkedlist.asp" target="_blank">LinkedList</a>


<br>Queue
<br><br>HashMap + TreeMap<br><br>Streams are a data flow. There are two types of operations: intermediary and terminal.<br><br>By default, checks the reference of an object. The common override of an equals is by checking the contents of the object.<br><br>Hashcode is a integer code that is the name of a bucket. This bucket contains a lot of objects. If two objects are identical, then their hashcode is the same. You can only use the hashcode of things that were put in an equal override.<br><br>Objects put in a TreeSet have to be comparable.<br><br><br>Exceptions that are thrown by the libraries, that are supposed to be acknowledged.<br><br>Exceptions that should not be thrown, and if they are, there is something wrong with the logic of your code.<br><br>Long term support (LTS) - The last one is JAVA 21.<br>[¹]: Java virtual machine<br><img alt="Pasted image 20240625110314.png" src="takitechs/pasted-image-20240625110314.png">]]></description><link>takitechs/takitech-1-a-bit-of-everything.html</link><guid isPermaLink="false">Takitechs/Takitech 1 - A bit of everything.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 25 Jun 2024 09:03:16 GMT</pubDate><enclosure url="takitechs/pasted-image-20240625110314.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="takitechs/pasted-image-20240625110314.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Welcome]]></title><description><![CDATA[ 
 <br><br>Welcome to your OCP CHEAT SHEET !<br>
I have taken many, many notes from the OCP book, and tightened them into this (work in progress) little website.<br>I hope it will make the learning experience a bit more enjoyable and colorful!<br>You can navigate to the table of content on the right, or simply click one of the links below:<br>Note
If the Chapter name does not have its qualifier yet, it means I haven't gotten to it yet. It'll be there eventually!
<br>
<br><a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>
<br><a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>
<br><a data-href="CHAPTER 3 - MAKING DECISIONS" href="ocp/chapter-3-making-decisions.html" class="internal-link" target="_self" rel="noopener">CHAPTER 3 - MAKING DECISIONS</a>
<br><a data-href="CHAPTER 4 - CORE APIS" href="ocp/chapter-4-core-apis.html" class="internal-link" target="_self" rel="noopener">CHAPTER 4 - CORE APIS</a>
<br><a data-href="CHAPTER 5 - METHODS" href="ocp/chapter-5-methods.html" class="internal-link" target="_self" rel="noopener">CHAPTER 5 - METHODS</a>
<br><a data-href="CHAPTER 6" href="ocp/chapter-6.html" class="internal-link" target="_self" rel="noopener">CHAPTER 6</a>
<br><a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>
<br><a data-href="CHAPTER 8" href="ocp/chapter-8.html" class="internal-link" target="_self" rel="noopener">CHAPTER 8</a>
<br><a data-href="CHAPTER 9" href="ocp/chapter-9.html" class="internal-link" target="_self" rel="noopener">CHAPTER 9</a>
<br><a data-href="CHAPTER 10" href="ocp/chapter-10.html" class="internal-link" target="_self" rel="noopener">CHAPTER 10</a>
<br><a data-href="CHAPTER 11" href="ocp/chapter-11.html" class="internal-link" target="_self" rel="noopener">CHAPTER 11</a>
<br><a data-href="CHAPTER 12" href="ocp/chapter-12.html" class="internal-link" target="_self" rel="noopener">CHAPTER 12</a>
<br><a data-href="CHAPTER 13" href="ocp/chapter-13.html" class="internal-link" target="_self" rel="noopener">CHAPTER 13</a>
<br><a data-href="CHAPTER 14 - IO" href="ocp/chapter-14-io.html" class="internal-link" target="_self" rel="noopener">CHAPTER 14 - IO</a>
<br><a data-href="CHAPTER 15" href="ocp/chapter-15.html" class="internal-link" target="_self" rel="noopener">CHAPTER 15</a>
<br>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Mon, 15 Jul 2024 11:26:08 GMT</pubDate></item><item><title><![CDATA[Introduction]]></title><description><![CDATA[ 
 <br><br><br>
<br>The exam does give negative points: check everything !
<br>Out of scope material means that we don't need to understand it, everything is implicit or given to us.
<br>words with strong meanings and absolute, such as ought, must or have to means that there is no edge case. Look very closely for one.
<br><br><br>A main() method has a very specific signature.<br>The very basic main() looks like this:<br>public class example {
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
Copy<br><br>We follow the rules below when creating a java class:<br>
<br>Each file can contain only one public class
<br>The filename must match the class name, including case, and have a .java extension.
<br>If the java class is an entry point for the program, it must contain a valid main() method.
<br>Let's take a look at the main()method:<br>
<br>publicis an access modifier, meaning that it declares the exposure to other callers in the program. See <a data-href="CHAPTER 5 - METHODS" href="ocp/chapter-5-methods.html" class="internal-link" target="_self" rel="noopener">CHAPTER 5 - METHODS</a>.
<br>staticmeans it can be called with just the class name. More in <a data-href="CHAPTER 6" href="ocp/chapter-6.html" class="internal-link" target="_self" rel="noopener">CHAPTER 6</a>.
<br>voidis a return type. This one in particular means it returns control to the caller silently, without returning anything. See <a data-href="CHAPTER 5 - METHODS" href="ocp/chapter-5-methods.html" class="internal-link" target="_self" rel="noopener">CHAPTER 5 - METHODS</a>.
<br>Any of there different modifiers are accepted:<br>String[] args
String options[]
String... friends
Copy<br>And you can also use the optional final modifiers:<br>public final static void main(final string[] args) {}
Copy<br><br>In the exam...
The exam will not try to trick you into giving you wrong package names.
<br>Java uses imports to look for different methods and symbols in other packages.<br>Wildcards (*) import everything in the package, but not child packages.<br>
For example, in order to import import java.util.concurrent.atomic:<br>import java.util.* //Doesn't import atomic
import java.util.concurrent.atomic.* //Imports atomic
Copy<br>Furthermore, in case of redundant class names in packages, you need to precise which is what. Also remember that precise named packages take precedence over names included in wildcard.<br>
For example:<br>import java.util.* //Contains method Date
import java.sql.* //Also contains method Date
Date a = new Date(); //DOES NOT COMPILE
Copy<br>Instead, you should do this:<br>import java.util.Date //Takes precedence
import java.sql.*
Date a = new Date(); //Uses java.util.Date
Copy<br>Note
If you absolutely need to use both Date from different packages, you can explicitly use their fully qualified class name.<br>
For example:
public class Conflicts {
	java.util.Date date;
	java.sql.Date sqlDate;
}
Copy
<br>You don't need to know...
You don't need to know about all the package names: if you're not supposed to know one, OCP will give you its name up top.
<br>Required Knowledge
The only package you need to know is imported automatically is java.lang, along with all the sub packages coming with it.
<br>Finally, this is how classes should be declared:<br>package structure; //Package first
import java.util.*; //Import second
public class Info { //Class declaration third
	String description; //Then either methods or fields
	private getDescription() {
	}
}
Copy<br>Not a constructor!
In the exam, there can be a method that looks like this:
public class Chick {
	public void Chick() { } //not a constructor!
}
Copy
This compiles but is not called in a new instruction.
<br><br>When setting up a java class, the order of operations goes this way:<br>public class Chick {
	private String name = "Fluffy";
	{ System.out.println("Setting Field"); }
	
	public Chick() {
		name = "Tiny";
		System.out.println("Setting Constructor");
	}
	
	public static void main(String[] args) {
	Chick chick = new Chick();
	System.out.println(chick.name);
	}
}
Copy<br>Running this example prints this:<br>
setting field setting constructor Tiny`<br>The fields are instantiated first (hence the setting field), then the constructor (with the setting constructor) and finally the rest of the main (Tiny).<br>In the exam...
There will always be an exam question about initialisation order, so be sure to be ready for it.
<br>You will see more of this in <a data-href="CHAPTER 6" href="ocp/chapter-6.html" class="internal-link" target="_self" rel="noopener">CHAPTER 6</a>.<br><br><br>The exam assumes that you are well versed in the eight primitive types, their sizes, and what's stored in them.<br>
They are the following:<br><br>But what about String?
String is considered the ninth primitive because of the built-in java support. Remember however that it is still an object.<br>
See more on <a data-href="CHAPTER 4 - CORE APIS" href="ocp/chapter-4-core-apis.html" class="internal-link" target="_self" rel="noopener">CHAPTER 4 - CORE APIS</a>.
<br>What should I remember ?
byte, short, int, long are integers without decimals. A bigger one is twice as big as the previous.
floatrequires the letter f or F following a number so JAVA knows it's a float. Otherwise, it's a double.
long requires an l or L following the number so that JAVA knows it's a long. Otherwise, java will interpret a number without a decimal point as an int in most scenarios. It is then cast into a long if possible.
All numeric types are signed and reserve one bit to cover the negative range.
short and char are closely related. The only difference is that shortis signed, and char is unsigned. You can cast one to the other. You'll see more in <a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>.
You don't have to remember the max values, the exam will tell you when the code does not<br>
compile because of it.
<br>As a tip: you can have underscores for your literals to make reading easier.<br>
Both of those are valid literal declarations:<br>int million1 = 1000000;
int million2 = 1_000_000;
Copy<br>There are a few things you cannot do:<br>double notAtStart = _1000.00; //DOES NOT COMPILE
double notAtEnd = 1000.00_; //DOES NOT COMPILE
double notByDecimal = 1000_.00; //DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; //Ugly, but compiles
double reallyUgly = 1________2; //Also compiles
Copy<br>Primitives, methods and nulls
You cannot assign a method to a primitive, nor can you assign it a null. As such, the following lines won't compile:
int bad = 1211.length(); // DOES NOT COMPILE
int value = null; // DOES NOT COMPILE
Copy
<br><br>There are wrapper classes that you can create to assign methods to the int. Their equivalency is described as followed:<br><br>Those all include helpful methods.<br>What should I remember ?
In the exam, you don't have to know the methods associated with the wrapper classes. Simply look at their names, and assume they exist and are working as presented.
<br><br>Text blocks are like regular String such as :<br>String example = "Hello world!"
Copy<br>However, they allow for the use of characters not present in regular strings without escape codes:<br>String example = """ Hellowo World!
  *
 * *
* * *
""";
Copy<br>Note
The line at the end of the code block leaves an empty line when the String is printed.<br>
A \ at the end of a line means that we do not want a new line to be added.
<br>Be careful!
The following block of code does not compile:
String incorrect: """compiler"""
Copy
Because text blocks need a line break.
<br>Tricks ahead!
Be careful, as incidental whitespace is not counted in text blocks. For example:
String textBlock = """
	java
	   &lt;- some white space
	 """
Copy
This will be rendered with java, and &lt;- some white space.
<br><br>Identifiers are the names of variables. There are some nuances as to what you can name and cannot name a variable.<br>
<br>Names have to start with a letter, a currency symbol (€, $, £, etc...), or a _.
<br>Identifiers can include numbers but never start with them.
<br>A single _ is not allowed.
<br>You cannot use reserved words.
<br>In the exam...
You don't need to know all reserved words. The exam will only ask for the very common ones, such as class, for, etc...<br>
However, you will be tested on the validity of some identifiers. See more in <a data-href="CHAPTER 12" href="ocp/chapter-12.html" class="internal-link" target="_self" rel="noopener">CHAPTER 12</a>
<br>There are also ways to declare many variables on the same line, showcased in the following example:<br>String s1, s2;
String s3 = "yes", s4 = "no";
Copy<br>Four variables were declared, s1, s2, s3 and s4.<br>
This works as long as all the variables are of the same type. Example:<br>String s1, int s2 = 2; // DOES NOT COMPILE
String s3, String s4; // DOES NOT COMPILE
Copy<br>This does not compile, because the inline declaration has to be only for variables reference of the same type.<br><br>Variables need to be initialized to be used. However, there are some rules to what you can do to certain variables.<br><br><br>A local variable is a variable that is defined in a constructor, method or initializer block.<br><br>staticvariables are called class variables. They are common across all instances of a class, and can be accessed without initializing them. They are the opposite of an instance variable, that remains specific to each declaration of an object. You can find examples of both class and instance variables in the <a data-href="#Instance variables" href="about:blank#Instance_variables" class="internal-link" target="_self" rel="noopener">Instance variables</a> sub chapter.<br>Default values
You don't need to instantiate static variables. They are given the common default value on startup.
static int value;
Copy
Will be able to be accessed from anywhere, as the compiler gave it the default 0value. To see which values are a default for each variable type, head over to <a data-href="#Data Types" href="about:blank#Data_Types" class="internal-link" target="_self" rel="noopener">Data Types</a>.
<br><br>Instance variables are the opposite of class variables, as they are unique and isolated for every instance of a class created.<br>public class Example() {
	static int a; // class variable
	int b; // instance variable
	
	public Example(int a, int b) {
	a = a;
	this.b = b;
	}
}

public class Test() {
	Example example1 = new Example(1, 1);
	Example example2 = new Example(2, 2);
}
Copy<br>At the end of the above example, example1 will have a = 2 because it has been reassigned globally through example2, but b = 1 because it is unique to example1. However, example2 will have a = 2 and b = 2, for the same aforementioned reasons.<br><br>Final variables are variables that have the keyword final attributed to them. These variables are unable to be modified, other than at initialization.<br>final int x = 10;
x = 20; // DOES NOT COMPILE
Copy<br>This does not compile, as you are trying to reassign a value to a finalvariable.<br>Caveat
Be careful, as only the value of the variable remains unchanged. For example:
final int[] numbers = new int[10];
numbers[0] = 1;
numbers = null; //DOES NOT COMPILE
Copy
Does not work, but only because we tried to reassign the value of the variable, not their pointers.
<br><br>Variables can be uninitialized. The compiler does not mind as long as you don't try to manipulate them. For example:<br>int number; // This is fine
System.out.println(number); // DOES NOT COMPILE
Copy<br>Trying to print out number fails compilation, but it would have been fine if you never used it.<br>In the exam...
There will be tricks about initialization. Be very wary of late initialisations, as there is reportedly at least one question that tricks you this way.
<br><br>As per the previous sub chapter, we saw that uninitialized variables are often the cause of Compile errors. However, there is a subtlety when those variables are passed in functions:<br>public void findAnswer(boolean check) {
	System.out.println(check); // COMPILES
}

public void checkAnswer() {
	boolean value;
	findAnswer(value); // DOES NOT COMPILE
}
Copy<br>The compilation error only happens at findAnswer(value), as the inside of a function assumes that every passed parameter has been initialized.<br><br>The var type is a wildcard type, formally named local variable type inference. You can use it instead of a value type for any local variable.<br>Be careful!
In the exam, they will try to trick you with var not assigned to local variables. For example:
public class VarKeyword {
	var tricky = "Hello"; // DOES NOT COMPILE
}
Copy
This does not work because tricky is not a local variable, but rather an instance variable. See what a <a data-href="#Local variables" href="about:blank#Local_variables" class="internal-link" target="_self" rel="noopener">Local variables</a> is here.
<br>var does not mean that the type of the variable can change at any time. It saves you the hassle of determining it, but the compiler will simply replace the var type with the true type that was inferred at the beginning.<br>Tricks ahead!
var HAS TO BE INSTANTIATED ON THE SAME LINE. It will NOT work if you try to apply a var without assigning it anything.<br>
For example:
var a = 1; // That's fine
var b; // DOES NOT COMPILE
int c = 1, var d = 1; // DOES NOT COMPILE
var e = null; // DOES NOT COMPILE
var f = 1, g = 1; // DOES NOT COMPILE
Copy
Do note that assigning it a null also doesn't work, as null could be attributed to any type of object. You can, however, assign a null to a var variable later on, once it has been assigned an object.
A second trick is to pass var in a method or constructor parameter. This does not, and will never work.
public int addition(var a, var b) { // DOES NOT COMPILE
	return a + b;
}
Copy
Finally, var's underlying type can and will be a primitive if possible. Be careful!
<br>Reserved words
var is not a reserved word, and can be used as an identifier. You can also use Var as a class name, since java is case sensitive.<br>
Exam people usually use this fact to write tricky code.
<br>To go further...
You can read more about var and its practical uses <a data-tooltip-position="top" aria-label="https://openjdk.java.net/projects/amber/LVTIstyle.html" rel="noopener" class="external-link" href="https://openjdk.java.net/projects/amber/LVTIstyle.html" target="_blank">here</a>
<br><br>A variable always has a defined scope. The scope keyword simply means everywhere that variable is able to be used.<br>The scope of a local variable is defined in the statement block it has been created, and every children statement thereafter.<br>
For example:<br>public void example(boolean test) {
	if (test) {
		boolean answer = true;
		//...
	} else {
		boolean notAnswer = true;
	}
}
Copy<br>In this code example, test is able to be used anywhere, as it has been declared as a method parameter. However, answer and notAnswer are only able to be used in the if ... else statement they have be instantiated in, and every children statement (if any). <br>Tricks ahead!
In the exam, they will try to trick you into thinking a question is about something complex, when in reality, the code doesn't compile because a variable is out of scope. Always make sure every variable is correctly used in its assigned scope first!
<br>The scope of the other two types of variables, instance and class variables, is easier to determine. Remember these rules:<br>
<br>local variables are in scope from declaration to end of the block.
<br>Method parameters are in scope for the duration of the method.
<br>Instance variables are in scope from declaration until eligible for garbage collection (when not referenced for example). For more about this, look into <a data-href="#Garbage collection" href="about:blank#Garbage_collection" class="internal-link" target="_self" rel="noopener">Garbage collection</a>.
<br>Class variables are in scope from declaration until the program ends.
<br><br>Java removes automatically the objects that can be deleted from your program. It uses algorithms that you don't need to know for the exam, but you need to be able to tell when an object is able to be collected for deletion.<br>Java stores every object and instance in the heap memory, or free store. When an object in the heap memory is not being referenced by anything in your program, it is able to be deleted.<br>You can call the garbage collector to do something with System.gc(), but it is not guaranteed to do anything.<br>Note
When a program end, not everything will picked up by the garbage collector. If there is still any data in the heap when the program end, the garbage collector will not pick it up.
<br><br>Object and References are two completely different notions. An object is something stored in the heap, and is what gets removed. It is the content. A reference is the pointer to that object, and is the same size, whatever the object it points to.<br>
For example:<br>String pointer = "object";
Copy<br>pointer is the reference to the object object. When the garbage collector comes, it will get rid of "object", not pointer.<br>As an example, we have this program:<br>public class scope {
	public static void main(String args[]) {
	String one, two;
	one = new String("a");
	two = new String("b");
	one = two; // GB gets rid of "a" since nothing references it.
	String three = one;
	one = null; // GB doesn't get rid of anything since three and two still point to "b"
	} // "b" goes out of scope, so GB gets rid of it.
}
Copy<br>You can see the two garbage collector rules here:<br>
<br>An object is collected if no reference points to it.
<br>An object is collected if it gets out of scope.
<br>In the exam...
Imports usually don't matter. if:

<br>The code begins with a class name
<br>The code begins with a method declaration
<br>The code begins with a code snippet
<br>The code begins with a line other than 1

Then assume the boilerplate code is written correctly.
<br><br>In the exam, you have to be able to:<br>
<br>Write code using a main() method. See more in <a data-href="#Main" href="about:blank#Main" class="internal-link" target="_self" rel="noopener">Main</a>.
<br>Understand Packages and Imports. See more in <a data-href="#Packages" href="about:blank#Packages" class="internal-link" target="_self" rel="noopener">Packages</a>.
<br>Recognize a constructor.
<br>Be able to recognize legal and illegal declarations and initialization. See more in <a data-href="#Initializing variables" href="about:blank#Initializing_variables" class="internal-link" target="_self" rel="noopener">Initializing variables</a> and <a data-href="#Uninitialized variables" href="about:blank#Uninitialized_variables" class="internal-link" target="_self" rel="noopener">Uninitialized variables</a>.
<br>Understand how to create text blocks. See more in <a data-href="#Text blocks" href="about:blank#Text_blocks" class="internal-link" target="_self" rel="noopener">Text blocks</a>.
<br>Determine when variables go in and out of scope. See more in <a data-href="#Variable scope" href="about:blank#Variable_scope" class="internal-link" target="_self" rel="noopener">Variable scope</a>.
<br>Determine when an object is eligible for garbage collection. See more in <a data-href="#Garbage collection" href="about:blank#Garbage_collection" class="internal-link" target="_self" rel="noopener">Garbage collection</a>.
<br>]]></description><link>ocp/chapter-1-building-blocks.html</link><guid isPermaLink="false">OCP/CHAPTER 1 - BUILDING BLOCKS.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Wed, 03 Jul 2024 14:19:33 GMT</pubDate></item><item><title><![CDATA[Chapter 3]]></title><description><![CDATA[ 
 <br><br><br><br>Control flow statements break up the flow of execution by using decision-making, looping and branching. This allows the code to execute selective and particular segments of code.<br>Note
These statements can be applied to either a single line of code, or a block of java code, delimited by balanced braced: {}.<br>
For example:
// Single statement
if (b)
	a++;
//Statement inside a block
if (b) {
	a++;
}
Copy
<br>Tricks ahead!
Be careful, as in this block:
if (b)
	a++;
	c++; // This line is not in the if statement!
Copy
<br><br>The if statement is useful to execute a block under certain circumstances.<br>
For example:<br>if (a &lt; 11) {
	System.out.println("a is less than 11.");
}
Copy<br>The program will only print out a is less than 11. if a is indeed strictly under 11.<br>Tips
In java, indentation and white space is not part of the program, it will be ignored by the java compiler.
<br><br>The else statement is only used whenever an if statement is present. If the if statement is not used, then the else block will always be executed.<br>
For example:<br>if (a &lt; 11) {
	System.out.println("a is less than 11.");
} else {
	System.out.println("a is more or equal than 11.");
}
Copy<br>If the if statement is not entered, aka a is more or equal than 11, then the else block will be triggered, thus printing "a is more or equal than 11.".<br>You can also use else statements followed by if statements for chained if/else statements.<br>
For example:<br>if (a &lt; 11) {
	System.out.println("a is less than 11.");
} else if (a &gt;= 11 &amp; a &lt;= 15) {
	System.out.println("a is between 11 and 15 included.");
} else {
	System.out.println("a is more than 15.");
}
Copy<br>This means that if the if statement is not triggered, then Java switches to the else if statement and evaluates it, and if this one also fails, then it switches to the final else statement, executing it.<br>Tricks ahead!
if statements need a boolean expression inside the evaluation block. And remember: 0 and 1 are not considered boolean values.<br>
For example:
int a = 1;
if (a) { // DOES NOT COMPILE
	//...
}
Copy
<br><br>To go further...
Pattern matching is also the name of the java Pattern class, along with regular expressions regex. This is not covered in this exam, but they are still good to know about !
<br>Pattern matching, from the java version 16, is a technique of controlling program flow that executes a section of code that meets a certain criteria. It is used in conjunction with if statements for greater program control.<br>
For example:<br>void compareIntegers(Number a) {
	if (a instanceof Integer)  {
		Integer b = (Integer) a;
		System.out.println(b.compareTo(5))
	}
}
Copy<br>This above code takes a lot of lines to:<br>
<br>Check if a is an instance of Integer
<br>Cast a into an Integer into variable b.
<br>Pattern matching lets you do this more efficiently:<br>void compareIntegers(Number a) {
	if (a instanceOf Integer b) {
		System.out.println(b.compareTo(5));
	}
}
Copy<br>The inside of the if statement automatically assigns a's value to b as an Integer if it's possible. This does not trigger a ClassCastException, as the casting only happens if it is possible.<br>
Here, b is called a pattern variable.<br>Good practice !
It is good practice to not reassign a pattern variable. Reassigning it can lead to ambiguity as to what is in or outside the scope.<br>
For example:
if (a instanceof Integer b) {
	b = 10;
}
Copy
Should not happen. If possible, use the final variable modifier, as shown in the following:
if (a instanceof final Integer b) {
	b = 10; // DOES NOT COMPILE
}
Copy
<br><br>Pattern matching includes expressions that can be used to filter data out.<br>
For example:<br>void printIntegerGreaterThan5(Number a) {
	if (a instanceof Integer b &amp;&amp; b.compareTo(5) &gt; 0) {
		System.out.print(b)
	}
}
Copy<br>This means that b will not be assigned, and the if statement will not be executed if b &gt; 5.<br>To go further...
You will see more about compareTo() on <a data-href="CHAPTER 4 - CORE APIS" href="ocp/chapter-4-core-apis.html" class="internal-link" target="_self" rel="noopener">CHAPTER 4 - CORE APIS</a> and <a data-href="CHAPTER 9" href="ocp/chapter-9.html" class="internal-link" target="_self" rel="noopener">CHAPTER 9</a>.<br>
But for now, just know that Integer.compareTo(int a):

<br>returns a value greater than 0 if the supplied value a is smaller than the integer we are comparing it to.
<br>returns a value smaller than 0 if the supplied value a is greater than the integer we are comparing it to.
<br>returns 0 if the supplied value a is equal than the integer we are comparing it to.

<br><br>The type of the pattern variable must be a subtype of the variable on the left side of the expression. It also cannot be the same type.<br>Be careful!
This rule does not exist for traditional instanceof operators.
<br>For example:<br>Integer a = 1;
if (a instanceof Integer) {}
if (a instanceof Integer b) {} // DOES NOT COMPILE
Copy<br>This does not work because pattern matching requires the second integer to be a strict subtype of Integer, and not just an Integer.<br>To go further...
Things will get a lot more complicated later. In <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>, you will see that java can get pretty confused about subtypes.<br>
Don't get too stressed, but this will work, for example:
Number a = 1;
if (value instanceof List) {}
if (value instanceof List b) {}
Copy
Even though List is not really a subtype of Integer.
<br><br>Flow scoping means a variable is only in scope when the compiler can definitely determine its type. The compiler uses flow scoping with pattern matching.<br>
It is an entirely different kind of scoping than the one seen previously in <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.<br>For example:<br>void example(Number a) {
	if (a instanceof Integer b || b.compareTo(5) &gt; 0) { // DOES NOT COMPILE
		System.out.println(b);
	}
}
Copy<br>In the above example, if a instanceof Integer b is false, then b is undefined, and since we are comparing using a OR operator, the second hand of the expression is triggered, leading to a compilation error since b is undefined.<br>Another example:<br>void example(Number a) {
	if (a instanceof Integer b) {
		System.out.println(b.intValue());
	}
	System.out.println(b.intValue()); // DOES NOT COMPILE
}
Copy<br>This example doesn't compile either, because a might not have inherited the Integer type, and b then wouldn't be instantiated.<br>Finally, one last example:<br>void example(Number a) {
	if (!(a instanceof Integer b)) {
		return;
	}
	System.out.println(b.intValue());
}
Copy<br>This code does compile. Let's take a look at an equivalent code that might be easier to understand:<br>void example(Number a) {
	if (a instanceof Integer b) {
		System.out.println(b.intValue());
	} else {
		return;
	}
}
Copy<br>We see here that only if b is instantiated, we end up using it. If it is not, we don't use it out of scope.<br>Required Knowledge
It is very important to understand how flow scoping works. If you understand that pattern variables might be used outside of an if statement, but only if the compiler can assuredly determine its type, then you understand everything!
<br><br>Stacking if / else statements is not the cleanest way to do multiple choice code. We use switch statements for this.<br><br>The switch statement is basically a large if / else statement. Here are the rules of the statement:<br>
<br>A single value will be evaluated on entry.
<br>The first branch that matches such value will be entered. Such a branch is called a case statement.
<br>If no such case statement is found that matches the value, the optional default statement will be called.
<br>If no such default statement is found, the entire switch statement will be skipped.
<br>For example, switch statements can be constructed like this:<br>switch (a) {
	case 1:
		// Code...
		break;

	case 2, 4:
		// Code...
		break;

	case 5: case 6:
		// Code...
		break;

	default:
		// Code...
}
Copy<br>Notice how you can combine values to look for on line 6. Also know that the break statements are optional, as seen in the default branch. Furthermore, said break statement may appear anywhere in the switch statement, not just at the end.<br>
Finally, line 10 is also weirdly written, but does indeed compile, and means that both case 5 and case 6 output the same code.<br>In the exam...
The exam will try to present you with invalid switch statements. Since switch statements can be longer than others, it is a good idea to check for their validity, to see if you're paying attention.
<br>For non-compiling examples, see below:<br>switch a { // DOES NOT COMPILE (needs parentheses)
	case 1 : System.out.println("a String");
}

switch (b) // DOES NOT COMPILE (needs curly braces)
	case 2 : System.out.println("a String");

switch (c) {
	case 3: 4: System.out.println("a String"); // DOES NOT COMPILE (needs comma after the 3)
}
Copy<br>The last example's correct notation would have been, on line 9, case 3, 4:.<br>Be careful!
During the exam, you might encounter such a statement:
switch (a) {}
Copy
This is a perfectly valid switch statement.
<br>Good practice !
default branches in switch statement are commonly used to throw exceptions. You'll see more of those in <a data-href="CHAPTER 11" href="ocp/chapter-11.html" class="internal-link" target="_self" rel="noopener">CHAPTER 11</a>
<br><br>break statements in switch statements are optional. Without them, any branch following the entered case statement will be executed, including any default branch found along the path.<br>For example:<br>switch (a) {
	case 1, 2, 3:
		System.out.println("String 1");
	case 4:
		System.out.println("String 2");
	case 5:
		System.out.println("String 3");
	default:
		System.out.println("Default");
	case 6:
		System.out.println("String 4");
}
Copy<br>If a equals 4 in the example above, then the output of such a program will be<br>
<img class="code-styler-inline-icon" src="blob://05e427d2-b375-40a9-9cbc-d2dd71af91a8">String 2 String 3 Default String 4
​.<br>Tricks ahead!
Exam makers are fond of switch statements, and they will try to give you a lot of those without the break statement at the end.
<br><br>Only a select list of data types and their wrapper classes are allowed to be compared on a switch statement.<br>
Here is an exhaustive list of them:<br>
<br>int and Integer
<br>byte and Byte
<br>short and Short
<br>char and Char
<br>String
<br>enum values
<br>var
<br>Note
You will see what enum values are later in <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>, for now, just know they are a list of fixed constants.
<br>Required Knowledge
var types are allowed, as long as their underlying type are one of the listed primitive types.<br>
Furthermore, know that boolean, long, float and&nbsp;double, along with their wrapper classes, are excluded from switch statements' allowed data types.
<br><br>case values can only accept literals, final and declared variables, and enum constants.<br>
For example:<br>final int getNumber() {return 1;}
void example() {
	final int a = 2;
	int b = 3;
	int c = 4
	final int d = getNumber();
	switch(b) {
		case a:
		case c: // DOES NOT COMPILE
		case d: // DOES NOT COMPILE
		case getNumber(): // DOES NOT COMPILE
		case 2 * 3:
	}
}
Copy<br>The variable a is final, so it is known at compile time, meaning the associated case statement is valid.<br>b is not final, so it's not a valid case statement.<br>
d is not final and its value is not known at compile time, so the case statement is not valid.<br>
getNumber() is the same case.<br>
Finally, 2 * 3 is a correct statement, as expressions are allowed, as long as they are resolvable.<br>Be careful!
Values must be able to fit in the data type without any explicit casting. This means numerical promotion is permitted. See more about numerical promotion in <a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>.<br>
Furthermore, the final variable used in the switch statement must be a local variable. Otherwise, the code does not compile.<br>
For example:
void example(final int a, int b) {
	switch(b) {
		case a : ; // DOES NOT COMPILE
		default : ;
	}
}
Copy
<br><br>The switch expression is a switch statement that can be stored in a variable, capable of returning a value.<br>
For the statement to be stored into a variable, we need to make sure every case has a compatible type with the variable.<br>
The switch expression supports two types of branches: expressions and blocks.<br>For example:<br>int result = switch(a) {
	case constantExpression -&gt; 5;
	case constantExpression², constantExpression³ -&gt; {
		yield 10;
	}
	default -&gt; 15;
}
Copy<br>In red, we have a case expression, that returns a simple value.<br>
In orange, we have a case block, that yields a value at the end of a code block.<br>
In yellow, we have the default block, required if no other branch is reached.<br>Note
There is an arrow operator (-&gt;) in the switch expression, but it is not a lambda expression.
<br>Here is an example that doesn't compile:<br>var a = switch(b) {
	case 10 -&gt; "a String"
	default -&gt; "another String"
}
Copy<br>This doesn't compile, because we're missing the semicolons required. For the code to compile, the following correction is required:<br>var a = switch(b) {
	case 10 -&gt; "a String";
	default -&gt; "another String";
};
Copy<br>The assignment itself needs the semicolon to correctly work.<br>Tips
The break statements aren't required in switch expressions, only the triggered line will be executed.
<br>Tricks ahead!
The switch expression can return a void value.<br>
For example:
var a = switch(b) {
	case 10 -&gt; System.out.println("A string");
	default -&gt; 10;
};
Copy
case 10 returns a void, which cannot be assigned to a variable, however.
<br>switch expressions come with additional new rules, discussed below:<br>
<br>All of the branches of a switch expression that do not throw an exception must return a consistent data type (if the switch expression returns a value).
<br>If the switch expression returns a value, then every branch that isn't an expression must yield a value.
<br>A default branch is required unless all cases are covered or no value is returned.
<br><br>You need to return a compatible data type to a variable for the switch statement to work.<br>
For example:<br>int a = 2;
int b = switch(a) {
	case 1 -&gt; 1;
	case 2 -&gt; (short)2;
	default -&gt; 3;
	case 3 -&gt; "4"; // DOES NOT COMPILE
	case 4 -&gt; 5L; // DOES NOT COMPILE
	case 5 -&gt; null; // DOES NOT COMPILE
};
Copy<br>All the cases that don't compile are because you cannot assign their type to an int without explicit casting.<br><br>A switch expression supports both expressions and a block in the case statement.<br>
It can return a value with a yield statement.<br>For example:<br>int a = 1;
int b = 2;
var c = switch(a) {
	case 1 -&gt; "a String";
	case 2 -&gt; {yield "another String";}
	case 3 -&gt; {
		if (b &gt; 2) yield "yet another String";
		else yield "String UWU";
	}
	default -&gt; "You won't believe this";
};
Copy<br>Be careful!
return breaks the switch statement, while yield returns the value correctly.
<br>For an example that doesn't compile:<br>int a = 1;
int b = 2;
var c = switch(a) {
	case 1 -&gt; "a String";
	case 2 -&gt; {} // DOES NOT COMPILE
	case 3 -&gt; {
		if (b &gt; 2) yield "yet another String";
		// DOES NOT COMPILE
	}
	default -&gt; "You won't believe this";
};
Copy<br>This does not work, because case 2 doesn't yield anything when it has to, and case 3 does not necessarily return anything (for example, if b &lt;= 2).<br>Tricks ahead!
One thing exam makers love trapping you with are semicolons in switch statements. Case expressions need a semicolon, while case blocks must not have one, and the end of the switch statement (after the brace) also needs one.
<br><br>This is the rule that will be tested the most on the exam. If all values are not covered by the switch statement and it has a return type, then the switch must contain a default branch.<br>For example:<br>String a = switch(b) { // DOES NOT COMPILE
	case 1 -&gt; "a String";
	case 2 -&gt; "another String";
};
Copy<br>Since this switch statement has a return value, it needs to cover all possible values (an infinity of them) or have a default statement.<br>Good practice !
If a switch statement takes in enum values, it might be tempting to not include a default branch since every permutation of the enum is easily covered. However, if someone adds a value to the enum, every switch will subsequently not compile. That is why you should always add a default branch, even if you know you have covered all permutations.
<br><br>Loops are pieces of code that run multiple times.<br><br>The simplest loop to write in java is the while loop.<br>
As long as the expression attached to the while loop is true, the while will keep executing the code inside its brackets.<br>Here's an example of how while loops are written:<br>while (boolExp) {
	// Code...
}
Copy<br>The boolExp is reevaluated every time the while executes the last statement in its body. When the while has executed the last statement, it reevaluates boolExp, and if it is false, then it exits the loop.<br>Note
As with <a data-tooltip-position="top" aria-label="The *if* statement" data-href="#The *if* statement" href="about:blank#The_*if*_statement" class="internal-link" target="_self" rel="noopener">if</a> statements, you only need curly braces if you have two or more lines to execute in your code.
<br>For example:<br>int a = 0;
while (a != 3) {
	System.out.println("+1");
	a++;
}
Copy<br>This code will print "+1" exactly 3 times, then a will be equal to 3, which will exit the loop.<br><br>A while loop can take another form, called the do/while loop. It behaves similarly as a while loop, with the exception that there is a guarantee that the loop will be executed at least once.<br>Here is how you write a do/while loop:<br>do {
	// Code executed at least once...
} while (boolExp)
Copy<br>For example:<br>int a = 3;
do {
	System.out.println("+1");
	a++
} while (a != 3)
Copy<br>Here, "+1" will only be printed out once, because the do/while loop executes the code once, sees that a is already equal to 3 which exits the loop.<br>Tricks ahead!
The boolExp is subject to scope problems as well: you cannot evaluate a variable if it is defined inside de while or do/while loop!<br>
For example:
while (a != 0) { // DOES NOT COMPILE
	int a = 0;
}
do {
	int a = 0;
} while (a != 0) // DOES NOT COMPILE
Copy
To see more about scope, please visit <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.
<br><br>A while loop can be infinite, in that it will never end. This does not get picked up by the compiler, so it will never throw a compiler error, but it will almost always result in a stack overflow error, memory leaks, slow performance or bad data.<br>Here is an example of the simplest infinite loop:<br>while (true) {
	// Code...
}
Copy<br>Since the boolean expression is always true, then the while will never exit.<br>
Be sure to always check the boolean condition is updated anywhere in the code, so that the while loop terminates correctly in all cases.<br>You will also learn later about break statements, which can stop a loop as well.<br><br>There are two types of for loops, the basic for loop, and the enhanced for loop, which both iterate over a code a specific number of times.<br><br>The for loop has two more new sections than the while loop. Besides the boolExp, there is an initialization with an updateStatement.<br>Here is how you initialize a for loop:<br>for (init; boolExp; updateStmnt) {
	// Code...
}
Copy<br>The flow of a for loop goes like this:<br>
<br>init statement executes
<br>If boolExp is true, continue, else, exit the loop
<br>Body executes
<br>Execute updateStmnt
<br>Return to step 2
<br>Be careful!
Also take a look at the following code snippet, placed on line 4 of the above code:
System.out.println(init);
Copy
If we try to read the init outside of the for loop, the variable is out of scope, and the code doesn't compile.
<br>Here is an concrete example of a for loop:<br>for (int i = 0; i &lt; 5; i++) {
	System.out.println(i + " ");
}
Copy<br>Here, we will get a result that looks like this: "0 1 2 3 4"
​.<br>Good practice !
Use the variable name i for loop iterations, it's a convention.
<br>Tips
You can put anything in the updateStmnt that updates the init variable. For example, to go in reverse, you write the following for loop:
for (int i = 4; i &gt;= 0; i--) {
	System.out.println(i + " ");
}
Copy
This will print "4 3 2 1 0".
<br>Required Knowledge
You need to know how to read forward and backwards for loops.  Pay attention when there is a backward for loop, as the exam makers are trying to test your knowledge of loop operations.
<br>Tricks ahead!
It doesn't matter how the updateStmnt is updated, it produces the same results.<br>
For example:
for (int i = 0, j = 0; i &lt; 5 || j &lt; 5; ++i, j++) {
}
Copy
Both i and j will be updated and have the same value inside the for loop.
<br><br>There are 5 iconic for loops that you need to familiarize yourself with for the exam.<br><br>The infinite for loop is a for loop that iterates infinitely. You build it like this:<br>for ( ; ; ) {
	System.out.println("Hellowo World");
}
Copy<br>This for loop not only does compile correctly, it also.<br>
This shows that each of the statements in a for loop are optional.<br><br>You can initialize multiple variables inside the init part of a for loop. For example:<br>int k = 0;
for (int i = 0, j = 0; i &lt; 5 &amp;&amp; j &gt;= -5 &amp;&amp; k != 5; i++, j--, k++) {
	System.out.println(i + " ");
}
System.out.println(k + " ");
Copy<br>You can see here that you can use outside variables in a for&nbsp;loop, initialize multiple variables inside the for&nbsp;loop, etc...<br><br>You cannot re-declare a variable that is already in scope in the init block in a for loop.<br>
For example:<br>int i = 0;
for (int i = 1; i &lt; 5; i++) { // DOES NOT COMPILE
	System.out.println(i + " ");
}
Copy<br>We are trying to redefine i inside the for&nbsp;loop, when it is already in scope.<br>
You can fix it by simply reassigning the variable instead of re-declaring it, like so:<br>int i = 0;
for (i = 1; i &lt; 5; i++) {
	System.out.println(i + " ");
}
Copy<br>We just reuse the variable.<br><br>The following example will not compile:<br>for (long i = 0, int j = 0; i &lt; 5 &amp;&amp; j &lt; 6; i++, j++) { // DOES NOT COMPILE
	System.out.println(i + " ");
}
Copy<br>The first line doesn't compile, because as seen in <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>, we cannot initialize variables on a single line if they're not of the same type.<br><br>As seen previously, variables defined inside the loop cannot be used outside of it.<br>
For example:<br>for (int i = 0; i &lt; 0; i++) {
	System.out.println(i + " ");
}
System.out.println(i); // DOES NOT COMPILE
Copy<br>This is because i is out of scope when getting out of the loop. See <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a> for more about scope.<br>Good practice !
It is a good practice to not modify loop variables inside of the loop.<br>
For example:
for(int i = 0, j = 0; i &lt; 10 &amp;&amp; j &lt; 10; i++, j++) {
	i = 0; // Bad :(
	j++; // No :(
}
Copy
<br><br>A for-each loop is a specialized tool that is designed to iterate over arrays and collections.<br>Here is how you build it:<br>for (datatype instance: collection) {
	// Code...
}
Copy<br>The for-each loop declaration is composed of an init section and the object to be iterated over.<br>The right side must be either:<br>
<br>A built-in Java array
<br>An object whose type implements java.lang.Iterable.
<br>To go further...
We'll see what implement means later in <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>.
<br>In the exam...
You need to know that the right side of a for-each is a List, a Set, an array or a Collection of items that implements the Collection&nbsp;interface.<br>
For example, Map is not supported in a for-each loop, although Map does indeed include methods that return Collection instances.
<br>For example:<br>public void example(List&lt;String&gt; as) {
	for(var a : as) {
		System.out.println(a);
	}
}
Copy<br>Because List&lt;T&gt; implements Iterable, it can be used inside of a for-each loop.<br>
Here, the var takes the type of the individual object in the List, so here, String.<br>Here are some examples that don't compile:<br>String as = "a String";
for (String a : as) { // DOES NOT COMPILE
	System.out.println(a);
}

String[] bs = new String[3];
for (int b : bs) { // DOES NOT COMPILE
	System.out.println(b);
}
Copy<br>The blue code doesn't compile because you cannot use a String as an Iterable.<br>
The indigo code doesn't compile because the type on the left side of the loop is an int, and therefore incompatible with the String[] type.<br><br>There are other ways to end the flow of a loop/statement than stopping it with a false value.<br><br>A nested loop is a loop that contains another loop.<br>For example:<br>int[][] ass = {{1,2,3},{4,5,6},{7,8,9}};

for(int[] as : ass) {
	for(int i=0; i&lt;as.length; i++) {
		System.out.println(as[i] + "\t");
	}
	System.out.println();
}
Copy<br>This is a nested for loop, because there is a first for loop, containing a second for loop.<br>To go further...
The int[][] is a multidimensional array, or an array that contains another set of arrays. We'll see more of this in <a data-href="CHAPTER 4 - CORE APIS" href="ocp/chapter-4-core-apis.html" class="internal-link" target="_self" rel="noopener">CHAPTER 4 - CORE APIS</a>.
<br>Nested loops can also contain do/while loops, while loops, for and for-each loops...<br>In the exam...
There will be some nested loops on the exam, make sure you know what they are and have some experience dealing with them!
<br><br>Labels are an optional pointer to the head of a loop. It is a single identifier followed by a colon (:).<br>For example:<br>int[][] ass = {{1,2,3},{4,5,6},{7,8,9}};

OUTER_LOOP: for(int[] as : ass) {
	INNER_LOOP: for(int i=0; i&lt;as.length; i++) {
		System.out.println(as[i] + "\t");
	}
	System.out.println();
}
Copy<br>Labels follow the same rules for formatting as identifiers. See more of those in <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>. <br>Good practice !
Usually, identifiers are expressed as ALL_UPPERCASE mixed with snake_case, with underscores (_) in the middle of words.
<br>You don't need to know...
You don't need to know about labels applied to control and block statements. While it is possible, it's not on the exam's menu.<br>
If you're curious still, know that the following is possible:
int a = 15;
BAD_IDEA: if(a&gt;10)
EVEN_WORSE_IDEA: {
	a++;
}
Copy
<br><br>The break statement exits the current statement and gives control to the enclosing statement.<br>
It basically ends the current loop early.<br>For example:<br>LABEL: while(boolExp) {
	// Code...
	break LABEL;
}
Copy<br>Here, we use an optional label to break the loop, but know that the break statement also works without labels. If no label is present on the break statement, then it will exit the nearest inner loop it is executing.<br>
Otherwise, if the label is present, it will exit the loop having the corresponding label.<br>For example:<br>public class example{
	public static void main(String[] args) {
		int[][] list = {{1,2},{2,2}};
		int search = 1;
		int X = -1;
		int Y = -1;
		PARENT_LOOP: for(int i=0; i&lt;list.length; i++) {
			for(int j=0; j&lt;list[i].length; j++) {
				if(list[i][j]==search) {
					X = i;
					Y = j;
					break PARENT_LOOP;
				}
			}
		}
		System.out.println("Value " + search + " found at " + X + ", " + Y);
	}
}
Copy<br>The above code will print out "Value 2 found at 0, 1"
​.<br>Be careful!
Remember that Lists begin with the index 0!
<br>This is because the break contains a label, and thus terminates the annotated loop. However, if it was like this instead:<br>if(list[i][j]==search) {
	X = i;
	Y = j;
	break;
}
Copy<br>Then the result would be "Value 2 found at 1, 0"
​, because the break wouldn't terminate the for on line 7, but would terminate the for on line 8, skipping the increment of j.<br>Finally, if the function was like this:<br>if(list[i][j]==search) {
	X = i;
	Y = j;
	//break;
}
Copy<br>Then, the result would be "Value 2 found at 1, 1"
​, because the break wouldn't terminate either the for on line 7 and on line 8, since it's not there. It would go through the entire list.<br><br>The continue&nbsp;statement is similar to the break statement, but rather than ending the flow of the current loop, it will transfer control to the boolExp that determine if the loop should continue. In other words, anything that is after the continue statement will be ignored at runtime.<br>
Just like break, continue can take optional labels to end a specific loop rather than the nearest loop.<br>For example:<br>LABEL: while(boolExp) {
	// Code...
	continue LABEL;
}
Copy<br>Here is an example of how it works:<br>public class Example {
	public static void main(String[] args) {
		LABEL: for(char a = 'a'; a &lt;= 'b'; a++) {
			for(int b = 1; b &lt; 4; b++) {
				if(a == 'b' || b == 2) {
					continue LABEL;
				}
				System.out.println("Done: " + a + ", " + b);
			}
		}
	}
}
Copy<br>In the above code, only when a == 'b'
​ or/and b == 2
​ will the continue statement be called.<br>
This means that we will get the following output:<br>
"Done: a, 1"
​<br>
"Done: c, 1"
​<br>
"Done: d, 1"
​<br>
This is because we reevaluate the loop LABEL, thus skipping the loop on line 4.<br>Now, if we did this:<br>if(a == 'b' || b == 2) {
	continue LABEL;
}
Copy<br>Then we'd get the following output:<br>
"Done: a, 1"
​<br>
"Done: a, 3"
​<br>
"Done: c, 1"
​<br>
"Done: c, 3"
​<br>
"Done: d, 1"
​<br>
"Done: d, 3"
​<br>
This is because we reevaluate the loop on line 4, thus skipping printing the letter b and the number 2.<br>If we removed the continue altogether, then everything would be printed.<br>Tricks ahead!
You cannot break or continue statements you haven't entered yet!<br>
For example:
int i = 0;
INNER: while(i &lt; 5) {
	i++;
	break OUTER; // DOES NOT COMPILE
	OUTER: while(i &lt; 3) {
		i++;
	}
}
Copy
<br><br>return statements can be used as a break to break out of an entire m̀ethod, but are also used to return a value between loops and statements.<br>For example:<br>public void example() {
	for(int i = 0; i &lt; 5; i++) {
		for(int j = 0; j &lt; 7; j++) {
			if (i == 2 &amp;&amp; j == 3) {
				return;
			}
		}
	}
}
Copy<br>In the code above, the method example will be exited whenever i and j are equal, respectively, to 2 and 3.<br><br>Any code that is directly after break, continue and return (meaning in the same block) is considered unreachable code, and will throw a compilation error.<br>For example:<br>int a = 1;
while (a &lt; 3) {
	a++;
	break;
	a++; // DOES NOT COMPILE
}
Copy<br>Tricks ahead!
It doesn't matter if the loop or decision structure actually visits the line of code, the compiler only sees that the code is not reachable statically. 
<br><br>As a summary, we can see what control statement is usable with what loop.<br><br>In the exam...
It is recommended to skip nested loop questions in the exam, unless you spot an obvious compilation error. Come back to those later when you finished everything else!
<br><br>In the exam, you have to be able to:<br>
<br>Understand if and else decision control statements. See more in <a data-href="#The *if* statement" href="about:blank#The_*if*_statement" class="internal-link" target="_self" rel="noopener">The *if* statement</a> and <a data-href="#The *else* statement" href="about:blank#The_*else*_statement" class="internal-link" target="_self" rel="noopener">The *else* statement</a>.
<br>Apply pattern matching and flow scoping. See more in <a data-href="#Shortening code with pattern matching" href="about:blank#Shortening_code_with_pattern_matching" class="internal-link" target="_self" rel="noopener">Shortening code with pattern matching</a>.
<br>Understand switch statements and their proper usage. See more in <a data-href="#The *switch* statement" href="about:blank#The_*switch*_statement" class="internal-link" target="_self" rel="noopener">The *switch* statement</a>.
<br>Use switch expressions correctly. See more in <a data-href="#The *switch* expression" href="about:blank#The_*switch*_expression" class="internal-link" target="_self" rel="noopener">The *switch* expression</a>.
<br>Write while loops. See more in <a data-href="#The *while* statement" href="about:blank#The_*while*_statement" class="internal-link" target="_self" rel="noopener">The *while* statement</a> and <a data-href="#The do/while statement" href="about:blank#The_do/while_statement" class="internal-link" target="_self" rel="noopener">The do/while statement</a>.
<br>Be able to use for loops. See more in <a data-href="#The *for* loop" href="about:blank#The_*for*_loop" class="internal-link" target="_self" rel="noopener">The *for* loop</a> and <a data-href="#The *for-each* loop" href="about:blank#The_*for-each*_loop" class="internal-link" target="_self" rel="noopener">The *for-each* loop</a>.
<br>Understand how break, continue and return can change flow control. See more in <a data-href="#The *break* statement" href="about:blank#The_*break*_statement" class="internal-link" target="_self" rel="noopener">The *break* statement</a>, <a data-href="#The *continue* statement" href="about:blank#The_*continue*_statement" class="internal-link" target="_self" rel="noopener">The *continue* statement</a> and <a data-href="#The *return* statement" href="about:blank#The_*return*_statement" class="internal-link" target="_self" rel="noopener">The *return* statement</a>.
<br>]]></description><link>ocp/chapter-3-making-decisions.html</link><guid isPermaLink="false">OCP/CHAPTER 3 - MAKING DECISIONS.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Sun, 23 Jun 2024 16:00:25 GMT</pubDate><enclosure url="blob:app://obsidian.md/05e427d2-b375-40a9-9cbc-d2dd71af91a8" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="blob:app://obsidian.md/05e427d2-b375-40a9-9cbc-d2dd71af91a8"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter 4]]></title><description><![CDATA[ 
 <br><br><br>A String is a sequence of characters.<br>
You can create one in three ways:<br>String a = "A string";
String b = new String("A string");
String c = """
			A string""";
Copy<br>Methods at line 1 and 2 are subtly different, as you'll see later in <a data-tooltip-position="top" aria-label="The *String* pool" data-href="#The *String* pool" href="about:blank#The_*String*_pool" class="internal-link" target="_self" rel="noopener">The String Pool</a>.<br>Since a String is a sequence of characters, it implements the CharSequence interface. You'll see more about interfaces on <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>.<br><br>You can concatenate two String by simply adding them together.<br>
For example:<br>String a = "1" + "1";
System.out.println(a);
Copy<br>The previous code snippet prints 11
​.<br>Tricks ahead!
Exam makers like using the + operator to confuse you with what they do.<br>
You have to remember 3 rules:

<br>If both operands are numeric, + means numeric addition.
<br>If either operand is a String, + means concatenation.
<br>The expression is evaluated left to right.<br>
For example:

System.out.println(1 + 2); // 3
System.out.println("a" + "b"); // ab
System.out.println("a" + "b" + 3); // ab3
System.out.println(1 + 2 + "c"); // 3c
System.out.println("c" + 1 + 2); // c12
System.out.println("c" + null); // cnull
Copy
Note that null is counted as a String if concatenated with a String.<br>
A common trick is shown in the following:
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four); // 64
Copy
Remember to check for types.<br>
Finally, one last thing to remember is the use of the +=operand:
var a = "1"; // a == "1"
var a += 2; // a == "12"
Copy
<br>Required Knowledge
All of this knowledge is very important for the exam, make sure you know everything before going in !
<br><br>String has a lot of methods you can call on it. However, there are just a handful of them, the ones you'll use most commonly, that you need to know about.<br>The first thing you need to know is about indexation of a String: They are indexed from 0, and hold a sequence of characters. For example:<br><br>The table above shows how the word "String"
​ would be indexed.<br>The second thing you need to know is that a String is immutable, or unchangeable. This means that calling a method on a String object will return a new String, rather than changing the one you initially referenced.<br>To go further...
You'll see more about immutable objects in <a data-href="CHAPTER 6" href="ocp/chapter-6.html" class="internal-link" target="_self" rel="noopener">CHAPTER 6</a>.
<br><br>The method length() returns the number of characters in a String. The method signature is as follows:<br>public int length()
Copy<br>Here is an example on how to use it:<br>String a = "String";
System.out.println(a.length());
Copy<br>The previous code outputs 6, as length() will always output the max index + 1, since we start counting at 1.<br>Tricks ahead!
Be wary that because of this, the following example is one of the exam maker's favorite tricks:
String a = "String";
System.out.println(a.charAt(a.length())) // IndexOutOfBoundsException
Copy
<br><br>The method chatAt lets you find the character positioned at a certain index.<br>
The method signature is as follows:<br>public char charAt(int index)
Copy<br>Here is an example on how to properly use chatAt():<br>String a = "String";
System.out.println(a.charAt(0)); // S
System.out.println(a.charAt(5)); // g
System.out.println(a.charAt(6)); // IndexOutOfBoundsException
Copy<br>As seen above in <a data-href="#Determining the length" href="about:blank#Determining_the_length" class="internal-link" target="_self" rel="noopener">Determining the length</a>, calling an index that is not defined in our String will result in an IndexOutOfBoundsException
​, meaning java tried to get an index that was not defined, couldn't, and didn't have a protocol to follow on how to proceed.<br>To go further...
You'll see more about exceptions on <a data-href="CHAPTER 7" href="ocp/chapter-7.html" class="internal-link" target="_self" rel="noopener">CHAPTER 7</a>.
<br><br>The method indexOf() looks at the characters in the String and finds the first index that matches the desired value. This method works with a single character as well as with a whole String. It can also start at a required position.<br>The method signatures are as follow:<br>public int indexOf(int ch)
public int indexOf(int ch, int FromIndex)
public int indexOf(String st)
public int indexOf(String st, String FromIndex)
Copy<br>Here is an example using indexOf() properly:<br>String a = "animal";
System.out.println('a'); // 0
System.out.println("al"); // 4
System.out.println('a', 1); // 4
System.out.println('b'); // -1
System.out.println('al', 5); // -1
Copy<br>Notice how trying to find a character that is not in the String with the requested parameters will return a -1.<br>Be careful!
Remember that you can pass Character type values to int!
<br><br>The method substring() also looks for characters in a String. However, rather than returning an index, the method returns a String.<br>The method signatures are as follow:<br>public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
Copy<br>Tricks ahead!
This method is a bit tricky:<br>
endIndex points to the end of the index you want to grab excluded, which means that the following is possible:
String a = "String";
System.out.println(a.substring(0, 6));
Copy
This will print out "String"
​ without any issue, even though a only has 5 indexes.
<br>The following example shows how to use substring() correctly:<br>String a = "String";
System.out.println(a.substring(3)); // ing
System.out.println(a.substring(a.indexOf('i'))); // ing
System.out.println(a.substring(3, 4)); // i
System.out.println(a.substring(3, 6)); // ing
Copy<br>Tips
An easier way to visualize substring() is to pretend that the index is just before the character it points to.<br>
Another trick to remember is that the number of returned characters is endIndex - beginIndex, so in every case, System.out.println(a.substring(3,5))
​ will return a String of 2 characters.
<br>Tricks ahead!
Finally, here are some tricks that the exam makers like to employ:
String a = "String";
System.out.println(a.substring(3, 3)); // empty String
System.out.println(a.substring(3, 2)); // Exception
System.out.println(a.substring(3, 7)); // Exception
Copy
Notice how a.substring(3,3) returns an empty String. This corroborates the tip section just above.<br>
Furthermore, choosing an endIndex that is smaller than beginIndex will result in an exception, as will choosing an endIndex that is bigger than the length of the String.
<br><br>The method toLowerCase() and toUpperCase() both respectively transform all upper case characters into lower case characters, and all lower case characters to upper case characters.<br>The methods signatures are as follow:<br>public String toLowerCase()
public String toUpperCase()
Copy<br>Here is an example on how to employ both correctly:<br>String a = "String";
System.out.println(a.toUpperCase()); // STRING
System.out.println(a.toLowerCase()); // string
System.out.println((a + "123").toUpperCase); // STRING123
System.out.println(a); // String
Copy<br>Notice how both of these methods leave alone any character that is not a letter.<br>
Also notice that a stays the same when printed at the end, because String is an immutable object.<br><br>The method equals() checks if the content of two String is strictly the same, meaning that they contain the exact same characters in the same order.<br>The method equalsIgnoreCare checks if the content of two String is strictly the same as well, barring the case of the characters.<br>Here are the methods signatures:<br>public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)
Copy<br>Notice how equals() takes in any Object. For now, remember that if you pass anything other than a String, the method will simply return false.<br>Here is an example on how to use both those methods properly:<br>System.out.println("abc".equals("ABC")); // false
System.out.println("ABC".equals("ABC")); // true
System.out.println("abc".equalsIgnoreCase("ABC")); // true
Copy<br>You don't need to know...
You used to have to know how to override toString(), equals() and hashCode() for the exam, but it is not the case anymore. If you are curious however, and it will definitely be useful for your job, here are the rules for overriding every of these methods:

<br>
toString(): The toString() method is called when you try to print an object or concatenate the object with a String. It is commonly overridden with a version that prints a unique description of the instance using its instance fields.

<br>
equals(Object): The equals(Object) method is used to compare objects, with the default implementation just using the == operator. You should override the equals(Object) method any time you want to conveniently compare elements for equality, especially if this requires checking numerous fields.

<br>
hashCode(): Any time you override equals(Object), you must override hashCode() to be consistent. This means that for any two objects, if a.equals(b) is true, then a.hashCode() == b.hashCode() must also be true. If they are not consistent, this could lead to invalid data and side effects in hash-­based collections such as HashMap and HashSet.


<br><br>The method startsWith() will look if the String starts with the provided prefix, and return true if that is the case.<br>The method endsWith() will look if the String ends with the provided suffix, and return true if that is the case.<br>The method contains() will look if the String contains the provided String anywhere, and return true if that is the case.<br>Here are the methods signatures:<br>public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)
Copy<br>Here are example on how to properly use these methods:<br>System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false

System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false
Copy<br><br>The method replace() simply replaces any match with the provided character or sequence of characters with the target character or sequence of characters.<br>Here are the method signatures:<br>public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)
Copy<br>Here is a proper way to use these methods:<br>System.out.println("abcabc".replace('a', 'A')); // AbcAbc
System.out.println("abcabc".replace("ab", "AB")); // ABcABc
Copy<br><br>The method strip() removes blank space from the beginning and/or the end of a String. This method also supports Unicode, namely \u2000.<br>The method trim() removes blank space from the beginning and/or the end of a String.<br>The method stripLeading() removes blank space from the beginning of a String.<br>The method stripTrailing() removes blank space from the end of a String.<br>You don't need to know...
Unicode is not on the exam, so don't bother trying to learn unicode whitespaces.
<br>Required Knowledge
In this case, whitespace also refers to \t (tab), \n (newline) and \r (carriage return). All of those get trimmed with every method mentioned above.
<br>Here are the methods signatures:<br>public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()
Copy<br>The following code shows how to use these methods:<br>System.out.println("abc".strip()); // abc
System.out.println("\t    a b c\n".strip()); // a b c

String text = " abc\t ";
System.out.println(text.trim().length()); // 3
System.out.println(text.strip().length()); // 3
System.out.println(text.stripLeading().length()); // 5
System.out.println(text.stripTrailing().length()); // 4
Copy<br>Be careful!
Remember that \t, \n and \r are single characters!
<br><br>The method indent() will add the specified number of whitespace at the beginning of the String. If you pass a negative number to this method, it will instead remove the specified number of whitespaces.<br>
Furthermore, this method will normalize whitespace, meaning that it will add a line break at the end of a String if it is not there. Then, it will convert all line breaks in any format to \n format.<br>The method stripIndent() will remove all leading incidental whitespace. To see more of what is incidental whitespace, refer to <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.<br>Be careful!
indent() with a negative number can be tricky: giving a larger negative number than there are leading whitespaces will not result in an error, instead, it will remove every whitespace it can find.
<br>Here is a summary of the rules to make it more clear:<br><br>Here are the methods signatures:<br>public String indent(int numberSpaces)
public String stripIndent()
Copy<br>And here are some example on how to use these methods:<br>String a = """
			a
			 b
			c""";
String b = " a\n"
		 + "  b\n"
		 + " c";
System.out.println(a.length()); // 6
System.out.println(b.length()); // 9
System.out.println(a.indent(1).length()); // 10
System.out.println(b.indent(-1).length()); // 7
System.out.println(b.indent(-4).length()); // 6
System.out.println(b.stripIndent().length()); // 6
Copy<br>Let's take a second to explain the difficult lines here;<br>
<br>Line 8 counts a, b, c, the whitespace before b, and the implied \n after a and b, which is 6 characters in total.
<br>Line 9 counts:

<br>On line 5: the whitespace + a&nbsp;+ \n, which is 3 characters.
<br>On line 6: the two whitespaces + b + \n, which is 4 characters.
<br>On line 7: the whitespace + c, which is 2 characters.
<br>All of it adds up to 9 characters in total.


<br>Line 10 adds a whitespace at the start of line 2, 3 and 4, plus adds a line break at the end of line 4 since it doesn't have one, adding up to 10 characters in total.
<br>Line 11&nbsp;removes a whitespace from line 5, 6&nbsp;and 7, leaving us with 6 characters. Then, indent() adds a line break at the end of line 7, adding up to 7 characters in total.
<br>Line 12 does the same as on line 11, but also removes the remaining whitespace character before b, leaving us with 6 characters in total.
<br>Line 13 counts how many leading whitespaces are common on each line of the block. There is only 1 common whitespace on those three lines, so stripIndent() removes a whitespace from line 5, 6 and 7. As stripIndent() doesn't add line breaks, we're left with 6 characters in total.
<br><br>The method translateEscapes() translates literal escapes into their equivalent escape characters.<br>The method signature is as follows:<br>public String translateEscapes()
Copy<br>Here is how to use that method:<br>String str = "1\\t2";
System.out.println(str); // 1\\t2
System.out.println(str.translateEscapes()); // 1    2
Copy<br>As you can see, the "\\t"
​ got translated to "\t"
​, which in turn got turned into a tab.<br><br>The method isEmpty() checks if the String has a length of 0.<br>The method isBlank() checks if the String contains strictly and only 0 or more whitespace characters.<br>Here is their method signature:<br>System.out.println(" ".isEmpty()); // false
System.out.println("".isEmpty());  // true
System.out.println(" ".isBlank()); // true
System.out.println("".isBlank());  // true
Copy<br><br>The method format() takes a String (and optionally, a Locale), and arguments to fit inside formatting flags.<br>The method formatted() only takes the arguments, and instead uses the current instance of the String to format with the formatting flags.<br>To go further...
You will see more about Locale on <a data-href="CHAPTER 11" href="ocp/chapter-11.html" class="internal-link" target="_self" rel="noopener">CHAPTER 11</a>.
<br>Here are the methods signatures:<br>public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)
Copy<br>Note
The trailing three dots (...) are called Varargs. it means that the function will take as many arguments as you'd like, as long as they're of the required type. You'll learn more about them in <a data-tooltip-position="top" aria-label="Using methods with *VarArgs*" data-href="#Using methods with *VarArgs*" href="about:blank#Using_methods_with_*VarArgs*" class="internal-link" target="_self" rel="noopener">Using methods with Varargs</a> and in <a data-href="CHAPTER 5 - METHODS" href="ocp/chapter-5-methods.html" class="internal-link" target="_self" rel="noopener">CHAPTER 5 - METHODS</a>. 
<br>Here are some examples on how to use these methods:<br>String a = "String";
int b = 6;

System.out.println("This " + a + " has a length of " + b);
System.out.println(String.format("This %s has a length of %d", a, b));
System.out.println("This %s has a length of %d".formatted(a, b));
Copy<br>The 3 different colored lines are functionally the same, as they all print "This String has a length of 6"
​.<br>Here are some of the different formatting flags that you will encounter commonly:<br><br>Required Knowledge
You need to know the different formatting flags inscripted above for the exam.
<br>Here is an example that uses all 4 flags tabulated above:<br>String a = "Pi";
int b = 15;
double c = 3.141592653589793;
System.out.println("Nasa only needs %d digits of %s to calculate interplanetary travel with a margin of error of less than an inch. Which means they use %s = %n%.15f".formatted(b, a, a, c));
Copy<br>This fun fact would print out the following:<br>
"Nasa only needs 15 digits of Pi to calculate interplanetary travel with a margin of error of less than an inch. Which means they use Pi =
​<br>
3.141592653589793"
​<br>Be careful!
As you might expect by now, java doesn't support mixing types and flags. Which means that, for example, mixing a float with a %d will result in an error.<br>
For example:
String a = "%d".formatted(2.0); // IllegalFormatConversionException
Copy
<br>Required Knowledge
As you may have noticed, the previous example contains a %.15f flag. By default, %f will print up to 6 digits after the floating point. You can readjust this precision by specifying the number of decimals you wish to print. Be careful, as it does not truncate the value, but rather rounds the value according to mathematics principles.<br>
For example:
double a = 3.141592653589793;
System.out.println("%f".formatted(a)); // 3.141593
System.out.println("%.1f".formatted(a)); //3.1
System.out.println("%.20).formatted(a)); // 3.1415926535897930000
Copy
As you can see, going further than the actual given digits will simply put trailing 0s at the end.<br>
That's not all however:<br>
You can specify the total length of the desired output by putting a number before the . in the flag. Remember that the . is counted in the length of the output.<br>
For example;
double pi = 3.14159265359;
System.out.format("[%f]",pi); // [3.141593]
System.out.format("[%12.8f]",pi); // [  3.14159265]
System.out.format("[%012f]",pi); // [00003.141593]
System.out.format("[%12.2f]",pi); // [        3.14]
System.out.format("[%.3f]",pi); // [3.142]
Copy
As you can see, the method, by default, will fill the empty space with blank spaces, but you can also fill the empty space with 0s if you place a single 0 before the decimal symbol.
<br>Note
Author's note:<br>
It was not explained well in the book, but after some tests, there are some more hidden rules that I am not sure will be present in the exam. If you are curious, here they are:
double pi = 3.14;
System.out.format("[%2f]", pi); // [3,140000]
System.out.format("[%9f]", pi); // [ 3.140000]
System.out.format("[%1.1f]", pi); // [3,1]
System.out.format("[%0.1f]", pi); // MissingFormatWidthException
Copy

<br>Line 2 showcases that even if the regular %f doesn't show it, the trailing 0s are still here if the passed floating number has less than 6 digits, and trying to show less than the total amount of characters (here, 8 in total) will simply print all 0s.
<br>As such, Line 3 demonstrates that only numbers above the length of the floating number including the invisible 0s will add spaces.
<br>Furthermore, Line 4 shows that the number before the floating point in the formatting flag will be ignored if it is smaller than the actual length of the floating number.
<br>Finally, putting a 0 before the . in the formatting flag will result in a MissingFormatWidthException.

<br>You don't need to know...
The format() method supports many more flags, but you don't need to know any that we haven't reviewed for the exam. If you still wish to know more, visit <a data-tooltip-position="top" aria-label="https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/rc/apidiffs/java/util/Formatter.html" rel="noopener" class="external-link" href="https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/rc/apidiffs/java/util/Formatter.html" target="_blank">the official documentation.</a>
<br><br>You can combine multiple methods by chaining them.<br>Here is an example on how to proceed:<br>String a = "StrIng    ";
String b = a.trim(); // "StrIng"
String c = b.toLowerCase(); // "string"
String d = c.replace('s', 'S'); //"String"

String e = a.trim().toLowerCase().replace('s', 'S'); // "String"
Copy<br>The pink highlighted code is equivalent to the red highlighted code, but we used method chaining in the red code to make it fit in a single line. Remember that you read method chaining from left to right.<br><br>The StringBuilder class behaves much like a String class, with the modified behavior that it is no longer immutable.<br>To go further...
If you're curious as to why this class was created, take a look at the following code extract:
String a = ""; // 1 Object
for (char b = 'a'; b &lt;= 'z'; b++) {
	a += b // + 1 Object created PER LOOP
}
System.out.println(a);
Copy
Since String objects are immutable, every time you call a method to modify them, a new instance is created. This means that the above code will create 27 new objects, all of which are immediately available for garbage collection.<br>
You will have guessed that this is extremely inneficient.<br>
Let's take the same code with a StringBuilder instead:
StringBuilder a = ""; // 1 Object
for (char b = 'a'; b &lt;= 'z'; b++) {
	a.append(b); // No new object created
}
System.out.println(a);
Copy
In this code, you see that there is only a single Object created, since StringBuilder just reassigns itself a new value.
<br>You don't need to know...
You used to need to know about StringBuffer, the thread-safe StringBuilder. It is not used anymore, so you don't need to know about it for the exam. However, you will need to know about concurrency, which is further explained in <a data-href="CHAPTER 13" href="ocp/chapter-13.html" class="internal-link" target="_self" rel="noopener">CHAPTER 13</a>.
<br><br>Unlike String, StringBuilder doesn't create a new instance of itself when modified, it simply reassigns its own value. This means that method chaining and method calling works differently.<br>For example:<br>StringBuilder sb = new StringBuilder("String");
sb.append("Builder");
System.out.println(sb);

String s = "String";
s + "Builder";
System.out.println(s);
Copy<br>Line 3 will print out "StringBuilder"
​, while line 7 will print out "String"
​, because we didn't reassign the output value of s + "Builder"
​ to a new String.<br>Tricks ahead!
The exam will really try to confuse you with String, StringBuilder and their immutability. Pay attention to both!
<br>Another crucial thing to note is that references to StringBuilder point to the same instance of StringBuilder when they are copied.<br>For example:<br>StringBuilder a = new StringBuilder("abc");
StringBuilder b = a.append("de");
b = b.append("f").append("g");
System.out.println("a=" + a);
System.out.println("b=" + b);
Copy<br>Both a and b will print out "abcdefg"
​. One simple trick to know how many StringBuilder instances are created is to look at how many calls to new StringBuilder()
​ are made, and here, it is only called once.<br><br>There are three ways to construct a StringBuilder:<br>StringBuilder a = new StringBuilder();
StringBuilder b = new StringBuilder("StringBuilder");
StringBuilder c = new StringBuilder(10);
Copy<br>Line 1 creates an empty StringBuilder.<br>
Line 2 creates a StringBuilder with the value "StringBuilder"
​ inside.<br>
Line 3 creates an empty StringBuilder with a capacity of 10 characters.<br>Be careful!
Just in case you are curious, you cannot do:<br>
<img class="code-styler-inline-icon" src="blob://05e427d2-b375-40a9-9cbc-d2dd71af91a8">StringBuilder a = "StringBuilder";
​<br>
As it will result in an Incompatible Type error.
<br><br>As with String, there are a few methods you will need to know for the exam. You don't need to know every single one of them, so here is a list of the minimum that you need to know.<br><br>The methods substring(), indexOf(), length() and charAt() behave the same way they do for Strings. In case you need a reminder:<br>
<br>The page for substring() is <a data-tooltip-position="top" aria-label="Getting a substring" data-href="#Getting a substring" href="about:blank#Getting_a_substring" class="internal-link" target="_self" rel="noopener">here</a>.
<br>The page for indexOf() is <a data-tooltip-position="top" aria-label="Finding an index" data-href="#Finding an index" href="about:blank#Finding_an_index" class="internal-link" target="_self" rel="noopener">here</a>.
<br>The page for length() is <a data-tooltip-position="top" aria-label="Determining the length" data-href="#Determining the length" href="about:blank#Determining_the_length" class="internal-link" target="_self" rel="noopener">here</a>.
<br>The page for charAt() is <a data-tooltip-position="top" aria-label="Getting a single character" data-href="#Getting a single character" href="about:blank#Getting_a_single_character" class="internal-link" target="_self" rel="noopener">here</a>.
<br>Let us still see how they work on StringBuilder:<br>StringBuilder a = new StringBuilder("String");
String b = a.substring(a.indexOf("S"), a.indexOf("n"));
int length = a.length();
char c = a.charAt(5);
System.out.println(b + " " + length + " " + c);
Copy<br>The above code will print out "Stri 6 g"
​.<br>
Notice how substring() returns a String rather than a StringBuilder. This means that a remains unchanged when calling substring(), which explains the result at line 5.<br>Make sure to visit any of the aforementioned pages if any of the methods confuse you.<br><br>The method append() adds the requested argument at the end of the StringBuilder.<br>One of the method signatures is as follows:<br>public StringBuilder append(String str)
Copy<br>Be careful, as there exists a ton of other append() method signatures, each taking different argument types, such as int and char for example.<br>As an example:<br>StringBuilder a = new StringBuilder().append(1).append('c').append(true);
System.out.println(a); // "1ctrue"
Copy<br>You don't need to convert anything to String for it to be properly appended to the StringBuilder.<br><br>The method insert() adds the requested argument at the specified index in the StringBuilder.<br>One of the method signatures is as follows:<br>public StringBuilder insert(int offset, String str)
Copy<br>Just as with append(), there exists more method signatures, each taking different arguments types.<br>As an example on how to use the method:<br>StringBuilder a = new StringBuilder("String");
a.insert(6, "#"); // a == "String#"
a.insert(0, "#"); // a == "#String#"
a.insert(4, "#"); // a == "#Str#ing#"
Copy<br>As with String's substring(), which you can find <a data-tooltip-position="top" aria-label="Getting a substring" data-href="#Getting a substring" href="about:blank#Getting_a_substring" class="internal-link" target="_self" rel="noopener">here</a>, you need to visualise each index being just before the character they represent, so that it is easier for you to understand what operation is performed.<br>
Furthermore, inserting at an index equal to the length of the StringBuilder will add your argument at the end of the StringBuilder.<br><br>The method delete() removes characters from the StringBuilder, and returns a reference to the current StringBuilder.<br>The method deleteCharAt() removes a single character from the StringBuilder and returns the reference to the current StringBuilder.<br>Here are the methods signatures:<br>public StringBuilder delete(int startIndex, int endIndex)
public StringBuilder deleteCharAt(int index)
Copy<br>Here is an example on how to use these methods:<br>StringBuilder a = new StringBuilder("String");
StringBuilder b = new StringBuilder("Builder");
a.delete(1, 3); // a == Sng
b.deleteCharAt(2); // b == Bulder
b.delete(1,100); // b == B
a.deleteCharAt(5); // exception
Copy<br>Notice how, on Line 5, using a delete() with an endIndex bigger than the length of the StringBuilder does not throw an exception, but simply deletes everything after the startIndex.<br>
Furthermore, make sure deleteCharAt() has a correct index as a parameter, or it will give a StringOutOfBoundsException.<br><br>The method replace() replaces with the specified sequence of characters by the specified String.<br>Here is the method signature:<br>public StringBuilder replace(int startIndex, int endIndex, String newString)
Copy<br>And here is how to properly use the method:<br>StringBuilder a = new StringBuilder("String Builder");
a.replace(4, 9, "wi");
System.out.println(a); // a == Striwilder

StringBuilder b = new StringBuilder("String Builder");
b.replace(4, 100, "");
System.out.println(b); // a == Stri
Copy<br>As with <a data-tooltip-position="top" aria-label="Deleting content" data-href="#Deleting content" href="about:blank#Deleting_content" class="internal-link" target="_self" rel="noopener">delete</a>, you can put endIndex as an index that is bigger than the length of the StringBuilder. replace() will understand that you want the whole StringBuilder starting with beginIndex to be replaced.<br>Be careful!
You need to know how replace() works:

<br>First, it performs a delete() on the specified sequence of characters.
<br>Only then, it inserts the newString at the startIndex.

<br><br>The method reverse() reverses the order of the sequence of characters.<br>Here is the method signature:<br>public StringBuilder reverse()
Copy<br>Here is how to use this method:<br>StringBuilder a = new StringBuilder("String");
a.reverse();
System.out.println(a); // "gnirtS"
Copy<br><br>Every Object contains a toString(), including StringBuilder.<br>
The method toString() returns a String.<br>Here is how you use this method:<br>StringBuilder a = new StringBuilder("String");
String b = a.toString();
Copy<br><br>We saw what the operator == means in <a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>.<br>
As a reminder, it helps you compare two references to the same object and String objects.<br><br>Consider the following code:<br>StringBuilder a = new StringBuilder();
StringBuilder b = new StringBuilder();
StringBuilder c = a.append("a");
System.out.println(a == b); // false
System.out.println(a == c); // true
Copy<br>As we are comparing references, a and b are two completely different objects, meaning that a != b, even if they are both functionally the same object. However, since c receives the instance contained in a, they both point to the same object, hence why a==c is true.<br>On the other hand, take a look at this code:<br>String d = "Hello world";
String e = " Hello world".trim();
System.out.println(d.equals(e)); // true
Copy<br>This only works because String implements the equals() method. As such, since the String objects have the same content, d.equals(e) evaluates to true.<br>However, StringBuilder does not implement equals(), meaning that calling that method on StringBuilder instances will check for reference equality.<br>Tricks ahead!
The exam makers will try to trick you with the == operator.<br>
For example:
String a = "String";
StringBuilder b = new StringBuilder("b");
System.out.println(a == b); // DOES NOT COMPILE
Copy
This does not work, because you cannot check for reference equality on two different types.
<br><br>String objects can use a lot of memory, simply because they are passed around everywhere.<br>Java knows this, and reuses common used String objects to reduce the memory usage. These reused String are put into the String pool, also known as intern pool.<br>This String pool contains literal values and constants that appear in the program.<br>
For example, a literal "literal"
​ will be stored into the String pool. However, the method toString() returns a String object, so not a literal.<br>Take a look at the following code snippet:<br>String a = "Hellowo World";
String b = "Hellowo World";
System.out.println(a == b); // true
b = " Hellowo World".trim();
System.out.println(a == b); // false
Copy<br>When creating those String objects, you access the literal Hellowo World. Since those references a and b point to the same object in memory, then the expression a == b evaluates to true.<br>However, line 5 showcases something else: we try to compare two different objects in memory who happen to have the same value.<br>
Let's take a closer look: Line 4 creates a literal that is Hellowo World, so it has a different memory address. What is important is that the String computed at Line 4 is computed at runtime. This means that if two objects are different at compile-time, then they cannot be equal at runtime.<br>
We will see a very specific exception to this rule in a second.<br>Be careful!
Remember that concatenation on the same line counts as it being a complete literal. For example:
String a = "Hellowo " + "World";
String b = "Hellowo World";
System.out.println(a == b); // true
Copy
<br>Here is another example:<br>String a = "Hellowo World";
String b = "Hellowo ";
b += "world";
System.out.println(a == b); // false
Copy<br>As with the rule we just saw, concatenating does not make an object equal to another.<br>Do you remember that we said that String a = "String";
​ and String a = new String("String");
​ are subtly different ?<br>
This is why:<br>String a = "Hellowo World";
String b = new String("Hellowo World");
System.out.println(a == b); // false
Copy<br>Line 3 would have printed true if we didn't use the new String()
​. We basically tell JAVA that we want to create a new object rather than refer to the String Pool.<br>Finally, there is an exception to the rule we defined up there, with the following method:<br>public String intern()
Copy<br>If the literal is not in the String pool, java will add it at the method's call.<br>This means that you can make two String with the same content equal. For example:<br>String a = "Hellowo World";
String b = new String("Hellowo World").intern();
System.out.println(a == b); // true
Copy<br>Even if the String at line 2 is a new object, we integrate it in the String pool with intern(), and since the literal already exists, then JAVA understands that both of these String point to the same object.<br>
This is why a == b equates to true.<br>String a = "String" + "Builder";
String b = "Str" + "ing" + "Builder";
String c = "String" + "Bui" + new String("lder");
System.out.prinlnt(a == b); // true
System.out.println(a == b.intern()); // true
System.out.println(a == c); // false
System.out.println(a == c.intern()); // true
Copy<br>As we saw earlier, a and b will point to the same literal in the String pool, since they are the same object at compile time.<br>
This means that Line 4 and 5 will return true.<br>
However, since we insert a new literal "lder"
​ at line 3, then Line 6 will equate to false.<br>
Finally, since we call the intern() method on c on line 7, we force java to realize that the value of variable c is the same that the one found in the String pool for a, thus line 7 returns true.<br>Good practice !
Don't actually create a String of a String or use the intern() method in real life. Doing so usually means that something else is wrong in your code. You should use equals() to check for String equality. Despite this, the exam still requires you to know how to do it.
<br><br>String and StringBuilder are a sequence of characters. That is because they are implemented using an array of characters.<br>An array is an area of memory on the <a data-tooltip-position="top" aria-label="CHAPTER 1 - BUILDING BLOCKS" data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">heap</a> with space for a designated number of elements.<br>String is implemented as an immutable array of characters, which length and content cannot be changed. It however implements helpful methods to return a new, modified String Object.<br>StringBuilder is implemented as a mutable array of characters, which can be replaced with a new array within the same object when it runs out of space to store new characters.<br>However, an array can be of any Java type. For example, if you didn't want to use a String, you could do the following:<br>char[] a;
Copy<br>Note
Keep in mind that in this example,  the reference a is not a primitive, but rather an array of primitives.
<br>What should I remember ?
Remember that an array is an ordered list that can contain duplicates.
<br><br>There are two ways of creating an array.<br>Here is an example of how to properly create a default array:<br>int[] a = new int[5];
Copy<br>The nomenclature is as follow:<br>
<br>The first int
​ is the type of the array.
<br>The first []
​ is the required array symbol.
<br>The [5]
​ is the size of the array.
<br>Be careful!
When instantiating anarray, all of the indexes will be filled with their default values. With the above example, this means the following:
int[] a = new int[5]; // a == [0,0,0,0,0]
Copy
If you need a reminder for default values, take a look at <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.
Furthermore, same as with String, indexes count up from 0.
<br>Another way of creating an array is to initialize it with content.<br>
For example:<br>int[] a = new int[] {1,2,3}; // a == [1,2,3]
Copy<br>It is however redundant, so java lets you write the following:<br>int[] a =  {1,2,3}; // a == [1,2,3]
Copy<br>This is called an anonymous array, as you don't specify the type and size of it.<br>Finally, you can also type the [] anywhere after the type of the array, meaning the following approaches are also valid:<br>int[] a;
int [] a;
int []a;
int a[];
int a [];
Copy<br>Tricks ahead!
Be wary of the placement of brackets ([]), as their position influence the type declaration in multi-line declarations. For a refresher on what multi-line declaration is, take a look at <a data-href="CHAPTER 1 - BUILDING BLOCKS" href="ocp/chapter-1-building-blocks.html" class="internal-link" target="_self" rel="noopener">CHAPTER 1 - BUILDING BLOCKS</a>.<br>
For example:
int[] a, b;
int c[], d;
Copy
The variable types for the code above are the following:

<br>a is of type int[]
<br>b is of type int[]
<br>c is of type int[]
<br>d is of type int<br>
d is only of type int because the brackets were placed after c, meaning they only apply to c. Be wary for this during the exam!

Goodpractice
It should go without saying, but don't ever write a multi-line declaration that looks like int c[], d;
​, it is unnecessarily confusing.

<br><br>You can create an array with any type of Java type, including the ones you create yourself.<br>
For example:<br>String[] a = {"String", "Object", "Array"};
String[] b = a;
System.out.println(b.equals(a)); // true
System.out.println(b.toString()); // [Ljava.lang.String;@120bc7c0
Copy<br>Be careful!
Calling equals() on an array does not look inside the array, it looks at the array object.<br>
This is why you can call equals() in the example above, because array is an object, and it returns true because of the reference equality.
<br>You don't need to know...
Line 4 of the code above is not on the exam, but in case you're curious, the return of the toString() looks like this because it have not been overridden.<br>
By default, toString() prints information on the object without looking at the content. In this case:

<br>[L means the object is an array.
<br>java.lang.String is the reference type.
<br>160bc7c0 is the hash code.<br>
You'll get a different code each time you run the snippet because it is a reference.

<br>Tips
Java does however provide nice ways of printing array objects, with Arrays.toString(a)
​ for example.
<br>Here are some more examples that should prove to be useful:<br>String a[]; // a == null
String b[] = new String[2]; // b == [null, null]
Copy<br>As shown here, be careful of what is instantiated, as line 1 does not specify anything, therefore making the array a equal to null.<br>
Line 2 does instantiate the array, but as seen before, if you do not specify the content of an array, it gets instantiated with the default value for the type, which is null in the case of String, an object.<br><br>array objects also provide a way of casting. If you need a refresher on what casting is, please visit <a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>.<br>Take a look at the following example:<br>String[] a = { "String" };
Object[] b = a;
String[] c = (String[]) b;
c[0] = new StringBuilder(); // DOES NOT COMPILE
b[0] = new StringBuilder(); // ArrayStoreException
Copy<br>Let's take a second to explain what is happening in the code above.<br>
<br>Line 1 creates an array of String named a.
<br>Line 2 stores this String[] into an Object[], which is possible because String is a subset of the type Object, so it doesn't require any type of casting.
<br>Line 3 casts Object[] back to String[] with an explicit cast.
<br>Line 4 tries to store a StringBuilder into an array of String, which is not possible, because StringBuilder is not a String.
<br>Line 5 tries to store a StringBuilder into an array of Object.

<br>This example does compile because StringBuilder is indeed an Object.
<br>This example doesn't run, however, because the underlying type of the Object is still a String, which means you cannot store a StringBuilder into it. This throws an ArrayStoreException.


<br>You don't need to know...
You don't need to know the exact name of the exception, ArrayStoreException, but you do need to know that it throws an exception.
<br><br>Getting the content of an array is how you use them. This is called accessing an array.<br>For example:<br>String[] a = {"b", "c", "d"};
System.out.println(a.length); // 3
System.out.println(a[0]); // "b"
System.out.println(a[1]); // "c"
System.out.println(a[2]); // "d"

String[] e = new String[5];
System.out.println(e.length); // 5
Copy<br>Make sure you understand that length prints out the number of allocated slots in the array, even if everything is null inside, as demonstrated by line 7 and 8.<br>Tricks ahead!
Do be careful with length in the exam. You do not need parentheses to length in an array, because it is not a method, but rather an attribute of the array.<br>
As such, be careful for code like this:
String[] a = {"String", "Object", "Array"};
System.out.println(a.length()); // DOES NOT COMPILE
Copy
Additionally, remember that accessing an array with array.length will always return an IndexOutOfBoundsException.<br>
For example:
String[] a = new String[5];
System.out.println(a[a.length]); // IndexOutOfBoundsException
Copy
This is a tactic very commonly used in loops. Whenever a loop is used to print out an array, pay close attention to the number of iterations and the length of the array. To see an example of a proper loop through an array. take a look at <a data-href="#Sorting" href="about:blank#Sorting" class="internal-link" target="_self" rel="noopener">Sorting</a>.
<br><br>The method Arrays.sort() will sort almost any array.<br>In order to use this method, you can use any of the following ways:<br>import java.util.*;
import java.util.Arrays;
Copy<br>Remember that if the imports aren't specified, you can assume they are correctly imported.<br>You don't need to know...
There is a third way of using sort(), but it doesn't come up in the exam.<br>
Here it is:
int[] a = {2,1,3};
java.util.Arrays.sort(a);
Copy
<br>Here is an example using the method, as well as a proper way to iterate through a loop to print every number in an array:<br>int[] a = {2,1,3};
Arrays.sort(a);
for (int i = 0; i &lt; a.length; i++) {
	System.out.println(a[i] + " ");
}
Copy<br>The result will be "1 2 3"
​.<br>Here is another example, with String instead:<br>String[] a = {"10", "9", "100"};
Arrays.sort(a);
System.out.println(Arrays.toString(a));
Copy<br>The result will be, however, "[10, 100, 9]"
​.<br>
This is because String sorts in alphabetical order, and 1 comes before 9 in the alphabet.<br>Required Knowledge
You should also know, in order of priority:

<br>numbers come before letters
<br>uppercase come before lowercase
<br>shorter words come before longer words

Here is an example illustrating the notions above:
String[] a = {"string", "String", "1string", "9string", "str"}
Arrays.sort(a);
System.out.println(Arrays.toString(a)); // [1string, 9string, String, str, string]
Copy
<br><br>The method Arrays.binarySearch() will search for the index of the specified value, but only in sorted arrays.<br>Here are the different case scenario:<br><br>Here is an example showcasing all of the scenario:<br>int[] a = {2,4,6,8};
System.out.println(Arrays.binarySearch(a, 2)); // 0
System.out.println(Arrays.binarySearch(a, 4)); // 1
System.out.println(Arrays.binarySearch(a, 1)); // -1
System.out.println(Arrays.binarySearch(a, 3)); // -2
System.out.println(Arrays.binarySearch(a, 9)); // -5
Copy<br>Notice that a is a sorted array. <br>
<br>Lines 2 and 3 return the index we expect.
<br>Line 4 returns -1. This means that 1 should be inserted at position 0 to keep the array sorted. (0 == ~-1)
<br>Line 5 returns -2, the bitwise of 1. (1 == ~-2).
<br>Line 6 returns -5, the bitwise of 4. (4 == ~-5).
<br>Note
If you need a refresher on bitwise operators (~), please visit <a data-href="CHAPTER 2 - JAVA OPERATORS" href="ocp/chapter-2-java-operators.html" class="internal-link" target="_self" rel="noopener">CHAPTER 2 - JAVA OPERATORS</a>.
<br>In the exam...
While there are some rules to predict the output of the undefined output when the array isn't sorted, the exam creators don't expect you to learn it.<br>
For example:
int[] a = {3,2,1};
System.out.println(Arrays.binarySearch(numbers, 3)); // UNDEFINED
Copy
While there will be an output, you don't have to calculate it. In the exam, when an array is unsorted, simply look for an answer that reads something similar to unpredictable output.
<br>To go further...
While you don't need to know how Arrays.binarySearch() operates, if you are curious, the method will split the array in half, and look to see which half the target is in. It repeats this process until there is one element left.
<br><br>There are two ways of comparing two arrays.<br><br>The method compare() returns a number depending on the compared arrays, following a set of rules.<br>
The rules are explained below.<br>Here is a table that reviews every rule first:<br><br>Here is a flowchart to determine the value returned by compareTo().<br><br>If you are wondering what smaller value means, take a look at the list below, ordered from smallest to largest:<br>
<br>null is smaller than any other type
<br>Numbers follow the same numeric order, 1 &lt; 2, 2 &lt; 3, etc...
<br>String objects:

<br>A String is smaller if it is a prefix of another.
<br>A String is smaller if it is uppercase.


<br><br>The method mismatch() returns -1 if the two arrays are equal, or the first index where they differ.<br>For example:<br>System.out.println(Arrays.mismatch(new int[] {1}, new init[] {1})); // -1
System.out.println(Arrays.mismatch(new String[] {"a"}, new String[] {"A"})); // 0
System.out.println(Arrays.mismatch(new int[] {1,2}, new int[] {1})); // 1
Copy<br>
<br>Line 1 possesses two identical arrays, so it returns -1.
<br>Line 2 differs at the first index, so it returns 0.
<br>Line 3 differs at the second index, so it returns 1.
<br>Here is a table summing up both methods to make sure you understood correctly:<br><br><br>Here is an example of Varargs first:<br>public static void main(String... args) {} // varargs
Copy<br>The three dots (...) are the Varargs arguments, or called variable arguments. You'll see more in <a data-href="CHAPTER 5 - METHODS" href="ocp/chapter-5-methods.html" class="internal-link" target="_self" rel="noopener">CHAPTER 5 - METHODS</a>, but for now, you simply need to know that the variable defined using Varargs are like a normal array.<br>For example:<br>args.length;
args[0];
Copy<br>Are both valid expressions.<br><br>Arrays can hold multiple arrays, thus making them multidimensional arrays.<br><br>You only need another set of brackets ([]) to create a multidimensional array.<br>
For example:<br>int[] a; // 1D array - a == []
int[][] b; // 2D array - b == [[]]
int[] c[]; // 2D array - c == [[]]
int d[][]; // 2D array - d == [[]]
int[] e[], f[]; // 2D array - e == [[]] + 3D array - f == [ [ [] ] ]
Copy<br>As you can see, there are multiple ways of creating a multidimensional array, although only the Line 2 should ever be used in real life, the rest is here only to confuse you.<br>You can also declare the space allocated for each sub-array, like so:<br>int[][] a = new int[3][2];
// a == [[0,0][0,0][0,0]]
// Or, another way of visualizing it:
// a == [[0,0]    // a[0] == [0,0]; a[0][0] == 0; a[0][1] == 0
//       [0,0]    // a[1] == [0,0]; a[1][0] == 0; a[1][1] == 0
//       [0,0]]   // a[2] == [0,0], a[2][0] == 0; a[2][1] == 0
Copy<br>In the example above, Line 4 corresponds to a[0], Line 5 corresponds to a[1], and Line 6 corresponds to a[2]. The first 0 corresponds to a[0][0], the second 0 corresponds to a[0][1], and so on.<br>The above example was a perfect rectangle, but you can also make irregular multidimensional arrays:<br>int[][] a = {{1,4}, {3}, {9,8,7}};
// a == [[1,4][3][9,8,7]]
// Or another way of visualizing it:
// a == [[1,4]     // a[0] == [1,4]; a[0][1] == 1, etc...
//       [3]
//       [9,8,7]]
Copy<br>Another way of doing it without instantiating everything with values is with the following method:<br>int[][] a = new int[4][]; // a == [[0][0][0][0]]
a[0] = new int[2]; // a == [[0,0][0][0][0]]
a[1] = new int[3]; // a == [[0,0][0,0,0][0][0]]
Copy<br>Tricks ahead!
You cannot instantiate a multidimensional array if you don't give the size of the first array.<br>
For example:
int [][] a = new int[][]; // DOES NOT COMPILE
int [][] b = new int[1][]; // a == [[0]]
Copy
<br><br>Using a multidimensional array means accessing its contents.<br>
You usually do this with a loop.<br>For example:<br>var a = new int[3][2];
for (int i = 0; i &lt; a.length; i++) {
	for (int j = 0; j &lt; a.length; j++) {
		System.out.print(a[i][j] + " "); // print element
	}
	System.out.println(); // prints out a new row
}
Copy<br>You will have recognized that this is a loop inside a loop. Be wary of the spot each variable occupies and learn to spot out of place variables so that you don't get tricked on the exam.<br>You can also use an enhanced for loop:<br>for (int[] i : a) {
	for (int j : i) {
		System.out.print(j);
	}
	System.out.println();
}
Copy<br><br>Java has a Math class that comes with helpful methods to help you compute numbers.<br>Tricks ahead!
Be wary, in general, of the return type of these methods, as they are the main source of trick questions on the exam.
<br><br>The methods min() and max() compare two values and return one of them.<br>Here are the method signatures for min() and max():<br>public static double min(double a, double b)
public static float min(float a, float b)
public static int min(int a, int b)
public static long min(long a, long b)

public static double max(double a, double b)
public static float max(float a, float b)
public static int max(int a, int b)
public static long max(long a, long b)
Copy<br>Understand that the method signatures for min() and max() are the exact same, they are simply all displayed here for exhaustiveness' sake*.<br>The min() method will return the smaller value of the two, while the max() method will return the bigger value of the two.<br>Here is an example using these methods:<br>int a = Math.max(3, 7); // 7
int b = Math.min(7, -9); // -9
Copy<br><br>The method round() gets rid of the decimal portion of the value, rounding up or down according to the usual mathematics rule set of rounding numbers.<br>Tips
As a reminder, rounding values follows one simple rule, if the number after the decimal is equal to or bigger than 5, then round up the integer part of the number.
<br>Here are the method signatures for round():<br>public static long round(double num)
public static int round(float num)
Copy<br>There is enough room in the first method to store a rounded double if needed.<br>Here are some examples showcasing the round() method:<br>long a = Math.round(123.45); // 123
long b = Math.round(123.50); // 124
int c = Math.round(123.45f); //123
Copy<br>Be careful!
You can see here that the 3rd method takes in a float because of the f flag. The return value of such method is always an int! It can, of course, be stored in a bigger type, but be careful to not get tricked.
<br><br>The method ceil() takes a double. If the double is a round number, it returns the original value, otherwise, it returns the rounded up value.<br>The method floor() takes a double, then discards any decimal value.<br>Here are the method signatures:<br>public static double ceil(double num)
public static double floor(double num)
Copy<br>Here are some example using both methods:<br>double a = Math.ceil(3.14); //4.0
double b = Math.ceil(3.0); // 3.0
double c = Math.floor(3.14); // 3.0
Copy<br><br>The method pow() computes exponents.<br>Tips
As a reminder, exponents work like demonstrated in the following:

The exponent, or the 3 in the example above, indicates how many times the exposed number is multiplied by itself.
<br>Here is the method signature:<br>public static double pow(double number, double exponent)
Copy<br>And here is how to use this method:<br>double a = Math.pow(5,2); // 25.0
Copy<br>You don't need to know...
While you can use fractional exponents with pow(), it is not on the exam.
Readmore
However, if you're curious, fractional exponents are the equivalent of square root powers.<br>
The most famous one is the 0.5 exponent:

Which is simply the square root of the exposed number.

<br><br>The method random() returns a value greater than&nbsp;0 and less than 1.<br>Here is the method signature:<br>public static double random()
Copy<br>And here is a proper way to use it:<br>double a = Math.random();
Copy<br>To go further...
While not on the exam, you can also use random() to generate numbers following other mathematical rules, like following a normal distribution for example, or simply to generate numbers bounded by numbers larger than 1.
<br><br>To work with Java's API dealing with dates and times, you need the following import: import java.time.*;
​.<br><br>There are four different ways of creating a Date/Time object depending on the amount of information you need for the exam.<br>Here is a table displaying them:<br><br>Note
Of course, you only need a select amount of information each time. Here are some example on why you'd need each of them:

<br>LocalDate is commonly used for birthdays, as you usually don't need the exact time of your birthday to celebrate it.
<br>LocalTime is commonly used for special hours in the day, like midnight, as it happens every day.
<br>LocalDateTime is commonly used for special events in the calendar, like new year's eve for example, as it happens at a certain date and certain time.
<br>ZonedDateTime is commonly used for international meetings, as you need very specific instruction to all connect at the same time if you're all strewn about on the planet.

<br>Here is how you'd use each of these static methods:<br>System.out.println(LocalDate.now()); // 2024-05-26
System.out.println(LocalTime.now()); // 16:17:40.190448143
System.out.println(LocalDateTime.now()); // 2024-05-26T16:17:40.190504675
System.out.println(ZonedDateTime.now()); // 2024-05-26T16:17:40.190847860+02:00[Europe/Paris]
Copy<br>The ZoneDateTime features a converter showing the time different from the UTC timezone, otherwise known as GMT timezone.<br>
To get this timezone, simply subtract the difference shown in the result. In the example above, that would be 16:17:40 - 2:00:00 = 14:17:40 UTC.<br>In the exam...
There are multiple way of displaying the different time zones, and the exam might use three of them: "+2:00"
​, "GMT+2"
​ or "UTC+2"
​, make sure you familiarize with them.<br>
Furthermore, java uses the format YYYY-MM-DD, as well as a 24H clock.
<br>We can also create a LocalDate, LocalTime, LocalDateTime and ZonedDateTime ourselves.<br>Here are the methods signatures:<br>public static LocalDate of(int year, int mont, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)

public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)

// The following is simply the above two combined
public static LocalDateTime of(int year, int month,
int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month,
int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month,
int dayOfMonth, int hour, int minute, int second, int nanos)

public static LocalDateTime of(int year, Month month,
int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month,
int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month,
int dayOfMonth, int hour, int minute, int second, int nanos)

// And this method takes a LocalDate and LocalTime to combine them
public static LocalDateTime of(LocalDate date, LocalTime time)

public static ZonedDateTime of(int year, int month,
int dayOfMonth, int hour, int minute, int second,
int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time,
ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)
Copy<br>Required Knowledge
Remember that int month counts up from 1, meaning January is 1, February is 2, etc...
Inexam
While there also are other ways of creating a ZonedDateTime, you only need to know these 3 ways for the exam.

Careful
Notice how there aren't any ZonedDateTime methods that allow the Month enum.

<br>Here are some examples on how to create instances of the aforementioned objects:<br>LocalDate a = LocalDate.of(2024, Month.JANUARY, 20);
LocalDate b = LocalDate.of(2024, 1, 20);

LocalTime c = LocalTime.of(6, 15); // 6 hours 15 minutes
LocalTime d = LocalTime.of(6, 15, 30); // + 30 seconds
LocalTime e = LocalTime.of(6, 15, 30, 200); // + 200 nanoseconds

LocalDateTime f = LocalDateTime.of(2024, Month.JANUARY, 20, 6, 15, 30);
LocalDateTime g = LocalDateTime.of(a, c)

ZoneId zone = ZoneId.of("Europe/Paris");
ZonedDateTime h = ZonedDateTime.of(2024, 1, 20, 6, 15, 30, 200, zone);
ZonedDateTime i = ZonedDateTime.of(a, c, zone);
ZonedDateTime j = ZonedDateTime.of(f, zone);
Copy<br>Tricks ahead!
While there are a lot of signatures to remember, the most common tricks the exam makers try to throw at you are the following:
LocalDate a = new LocalDate(); // DOES NOT COMPILE
LocalDate b = LocalDate.of(2024, Month.JANUARY, 32) // DateTimeException
Copy
In the first example, we show that there are no constructors for any of the classes we saw above.<br>
In the second example, we show that we cannot just pass anything in the parameters of the methods. If you try to pass an invalid month or day, you will be met with a DateTimeException.
Noknowledge
You don't need to know about the exact exception that is passed.

<br><br><br>The method plusDays() adds the specified number of days to the date.<br>
The method minusDays() subtracts the specified number of days to the date.<br>The method plusWeeks() adds the specified number of weeks to the date.<br>
The method minusWeeks() subtracts the specified number of weeks to the date.<br>The method plusMonths() adds the specified number of months to the date.<br>
The method minusMonths() subtracts the specified number of months to the date.<br>The method plusYears() adds to the specified number of years to the date.<br>
The method minusYears() subtracts to the specified number of years to the date.<br>They all take an int and return a new instance of LocalDate, as the LocalDate class is immutable.<br>Here are some examples on how to use each of the plus methods:<br>LocalDate a = LocalDate.of(2022, Month.JANUARY, 20); // 2022-01-20
a = date.plusDays(2); // 2022-01-22
a = date.plusWeeks(1); // 2022-01-29
a = date.plusMonths(1); // 2022-02-28
a = date.plusYears(1); //2023-02-28
Copy<br>You'll remark that Line 6 didn't add exactly one month. That is because 2022 is not a leap year, meaning that February 29th does not exist, so Java will subtract a day.<br>You'll see the minus methods in action in <a data-href="#Summary" href="about:blank#Summary" class="internal-link" target="_self" rel="noopener">Summary</a> below.<br><br>The method plusHours() adds the specified number of hours to the time.<br>
The method minusHours() subtracts the specified number of hours to the time.<br>The method plusMinutes() adds the specified number of minutes to the time.<br>
The method minusMinutes() subtracts the specified number of minutes to the time.<br>The method plusSeconds() adds the specified number of seconds to the time.<br>
The method minusSeconds() subtracts the specified number of seconds to the time.<br>The method plusNanos() adds the specified number of nanoseconds to the time.<br>
The method minusNanos() subtracts the specified number of nanoseconds to the time.<br>You'll see these methods in action in <a data-href="#Summary" href="about:blank#Summary" class="internal-link" target="_self" rel="noopener">Summary</a> below.<br><br>Here are some examples using both time and dates methods seen above.<br>LocalDate a = LocalDate.of(2024, Month.JANUARY, 20);
LocalTime b = LocalDate.of(5, 15);
LocalDateTime c = LocalDateTime.of(a, b); // 2024-01-20T05:15
c = dateTime.minusDays(1); // 2024-01-19T05:15
c = dateTime.minusHours(10); // 2024-01-18T19:15
c = dateTime.minusSeconds(30); // 2024-01-18T19:14:30
Copy<br>Do notice that Line 5 subtracts 10 hours from 05:15, making the day regress.<br>
Additionally, notice that Line 6 subtracts 30 seconds from 15 minutes, making the seconds appear. Understand that Java hides seconds and nanoseconds until we use them.<br>The previous example can be rewritten in the following, through method chaining:<br>var a = LocalDate.of(2024, Month.JANUARY, 20);
var b = LocalTime.of(5, 15);
var c = LocalDateTime.of(a, b)
.minusDays(1).minusHours(10).minusSeconds(30);
Copy<br>Tricks ahead!
The exam makers like to confuse you with immutable objects such as Date and Time Objects.<br>
For example:
LocalDate a = LocalDate.of(2024, Month.JANUARY, 20); // 2024-01-20
a.plusDays(10);
System.out.println(a); // 2024-01-20
Copy
The result stays the same, because we ignore the return value of plusDays(), because Date and Time are immutable and calling the method above does not change their assigned values.
Furthermore, calling the wrong method on the wrong class will result in a compiler error.<br>
For example:
LocalDate a = LocalDate.of(2024, Month.JANUARY, 20);
a = a.plusMinutes(1); // DOES NOT COMPILE
Copy
This is because you try to call the plusMinutes() method to a class that does not implement this method, because LocalDate has no notion of Time.
<br>Here is a recap on what method can be used with which class:<br><br><br>The class period contains a period of time. It is commonly used to add or subtract to Dates or Times, or to checkpoint when a certain period of time has passed.<br>For example:<br>LocalDate a = new LocalDate.of(2024, 1, 1);
a = a.plusMonth(1);

LocalDate b = new LocalDate.of(2024, 1, 1);
Period period = Period.ofMonths(1);
b = b.plus(period);
Copy<br>Both yellow and green highlighted code snippet do the same thing. While the use of period is not readily apparent, it is used when you're not sure about the amount of time you need to add.<br>For example, the yellow code can only add a month at Line 2, while the green code can add any kind of period of time at Line 6.<br>Here are the 5 method signatures that allow you to create a period:<br>public static Period ofYears(int years);
public static Period ofMonths(int months);
public static Period ofWeeks(int weeks);
public static Period ofDays(int days);
public static Period of(int years, int months, int days);
Copy<br>Here are some examples showing how to use these methods:<br>Period a = Period.ofYears(1); // every 1 year
Period b = Period.ofMonths(3); // every 3 months
Period c = Period.ofWeeks(3); // every 3 weeks
Period d = Period.ofDays(2); // every 2 days
Period e = Period.of(1, 0, 7); // every year and 7 days
Copy<br>Be careful!
You cannot chain those methods, as they are static methods. Trying to apply method chaining to these methods will result in only the last method being used.<br>
For example:
Period a = Period.ofYears(1).ofMonths(1);
Period b = Period.ofMonths(1);
System.out.println(a.equals(b)); // true
Copy
In the above code, we see that a and b are functionally equal, as they hold the exact same information, a period of 1 month.
<br><br>The String output of a Period is the following:<br>Period.toString() = "P" + "#years" + "Y" + "#months" + "M" + "#days" + "D";
​<br>Be careful, as if any of the # is 0, the corresponding period will be omitted.<br>For example:<br>System.out.println(Period.ofYears(1)); // P1Y
System.out.println(Period.ofMonths(3)); // P3M
System.out.println(Period.ofDays(5)); // P5D
System.out.println(Period.of(9,0,2)); // P9Y2D
System.out.println(Period.of(9,3,2)); // P9Y3M2D
Copy<br>Tricks ahead!
As you'd expect, trying to add a Period to an unsupported type will throw an exception.<br>
For example:
LocalTime a = LocalTime.of(6, 15):
Period b = Period.ofMonths(1);
a = a.plus(b); // UnsupportedTemporalTypeException
Copy
Trying to add a Date period to a Time-only class will result in an UnsupportedTemporalTypeException at runtime.
Noknowledge
As usual, you don't have to know the exact type of the exception, only that the code will throw one.

<br><br>The class Duration contains a duration of time. The difference with <a data-tooltip-position="top" aria-label="Working with periods" data-href="#Working with periods" href="about:blank#Working_with_periods" class="internal-link" target="_self" rel="noopener">periods</a> is that while Period is only for Date periods, Duration is only for Time periods.<br>Here are the methods signatures in Duration:<br>public static Duration ofDays(int days);
public static Duration ofHours(int hours);
public static Duration ofMinutes(int minutes);
public static Duration ofSeconds(int seconds);
public static Duration ofMillis(int milliseconds);
public static Duration ofNanos(int nanoseconds);
public static Duration of(int duration, ChronoUnit durationType);
Copy<br>You can see that the first 6 methods are very straightforward.<br>
The last one takes in a ChronoUnit, an implementation of TemporalUnit.<br>
Chronounit is an enum that allows for fine-grained durations.<br>Here are some examples displaying the use of the aforementioned methods:<br>Duration a = Duration.ofDays(1); // PT24H
Duration b = Duration.ofHours(1); // PT1H
Duration c = Duration.ofMinutes(1); // PT1M
Duration d = Duration.ofSeconds(10); // PT10S
Duration e = Duration.ofMillis(1); // PT0.001S
Duration f = Duration.ofNanos(1); // PT0.000000001S
Copy<br>And here is the same code snippet, but with Duration.of() to display its functions:<br>Duration a = Duration.of(1, ChronoUnit.DAYS);
Duration b = Duration.of(1, ChronoUnit.HOURS);
Duration c = Duration.of(1, ChronoUnit.MINUTES);
Duration d = Duration.of(10, ChronoUnit.SECONDS);
Duration e = Duration.of(1, ChronoUnit.MILLIS);
Duration f = Duration.of(1, ChronoUnit.NANOS);
Copy<br>Note
ChronoUnit also includes some other convenient units such as ChronoUnit.HALF_DAYS for example, to represent 12 hours.
<br>Here are some examples on how to use Duration:<br>LocalDate a = LocalDate.of(2024, 1, 20);
LocalTime b = LocalTime.of(6, 15);
LocalDateTime c = LocalDateTime.of(date, time);
Duration d = Duration.ofHours(6);
Duration e = Duration.ofHours(23);
System.out.println(c.plus(d)); // 2024-01-20T12:15
System.out.println(b.plus(d)); // 12:15
System.out.println(a.plus(d)); // UnsupportedTemporalTypeException
System.out.println(c.plus(e)); // 2024-01-21T05:15
System.out.println(b.plus(f)); // 05:15
Copy<br>You can see that everything works as expected:<br>
<br>Adding hours that overflow the modulo(24) of hours in a day will add a day, or simply wrap around the clock.
<br>Trying to add hours to LocalDate will result in an UnsupportedTemporalTypeException.
<br><br>The String output of a Durationis the following:<br>Duration.toString() = "PT" + "#Hours" + "H" + "#Minutes" + "M" + "#Seconds/millis/nanos" + "S";
​<br>Be careful, as if any of the # is 0, the corresponding duration will be omitted.<br><br>While ChronoUnit can be used in the Duration.of() method, it's not the only use we have for it. It can be great to determine how far apart two Temporal values are.<br>
Temporal are all the classes that deal with Time and Date, such as LocalDate, LocalTime, etc.<br>Remember that ChronoUnit is on the java.time.temporal package.<br>For example:<br>LocalTime a = LocalTime.of(5, 15);
LocalTime b = LocalTime.of(6, 30);
LocalDate c = LocalDate.of(2016, 1, 20);
System.out.println(ChronoUnit.HOURS.between(a, b)); // 1
System.out.println(ChronoUnit.MINUTES.between(a, b)); // 75
System.out.println(ChronoUnit.MINUTES.between(a, c)); // DateTimeException
Copy<br>Do notice a few things:<br>
<br>Line 4's difference is of 1h15, but since we want only ChronoUnit.HOURS, it truncates all minutes and returns the hour difference.
<br>Line 5 behaves as expected.
<br>Line 6 throws a DateTimeException because LocalDate does not contain any minutes.
<br>Finally, you can truncate and Time object. For example:<br>LocalTime a = LocalTime.of(3,12,45);
System.out.println(a); // 03:12:45
LocalTime b = a.truncatedTo(ChronoUnit.MINUTES);
System.out.println(b); // 03:12
Copy<br>Here, we see that the seconds get truncated.<br>Tricks ahead!
Remember: conversion and truncation does not round up or down. It only gets rid of unwanted parts of the object.
<br><br>Remember that Period and Duration are not interchangeable.<br>
Period will only work with Dates, and Duration will only work on Time.<br>
Here is a comprehensive table showing you what method you can use with what class:<br><br><br>The class Instant saves the current LocalDateTime from the GMT time zone.<br>Here is the method signature for this class:<br>public static Instant now()
Copy<br>Here is an example on how to use this method:<br>Instant a = Instant.now();
System.out.println(a); // 2024-06-06T09:09:05.938863964Z
Copy<br>You can also turn a ZonedDateTime into an Instant:<br>var date = LocalDate.of(2022, 5, 25);
var time = LocalTime.of(11, 55, 00);
var zone = ZoneId.of("US/Eastern");
var zonedDateTime = ZonedDateTime.of(date, time, zone);
var instant = zonedDateTime.toInstant(); // 2022–05–25T15:55:00Z
System.out.println(zonedDateTime); // 2022–05–25T11:55–04:00[US/Eastern]
System.out.println(instant); // 2022–05–25T15:55:00Z
Copy<br>Both lines 6 and 7 represent the same moment in time. However, Instant removes the time zone and turns it into an Instant of time in GMT.<br>Tricks ahead!
You can only use Instant with ZonedDateTime, as the other Date and Time do not contain time zones.
<br><br>Daylight Saving Time (DST) is the event where clocks are adjusted an hour forwards or backwards to make better use of the sunlight.<br>Note
Only the US DST is to be learned for the exam.
Inexam
The question will mention if the DST event will occur in the weekend the question takes place. If it doesn't, you can assume the even does not take place.

Remember
The US DST lands a Sunday morning at 2:00 am. The clocks advance forward in March and backward in November.<br>
Take a look at the following flowchart to learn how it works precisely:


Tips
A mnemonic trick to remember when to go forwards or backwards is by remembering the sentence Spring forward in spring, fall back in the fall.

<br>For example, on March 10 2024, the US's clocks moved forward an hour and jumped from 2:00 a.m to 3:00 a.m. That meant that there were no 2:30 a.m that day, instead transforming into 3:30 a.m.<br>Here is how moving forwards translates into JAVA:<br>var a = LocalDate.of(2024, Month.MARCH, 10);
var b = LocalTime.of(1, 30);
var c = ZoneId.of("US/Eastern");
var d = ZonedDateTime.of(a, b, c);
System.out.println(d); // 2024-03-10T01:30-05:00[US/Eastern]
System.out.println(d.getHour()); // 1
System.out.println(d.getOffset()); // -05:00
d = d.plusHours(1);
System.out.println(d); // 2024-03-10T03:30-04:00[US/Eastern]
System.out.println(d.getHour()); // 3
System.out.println(d.getOffset()); // -04:00
Copy<br>Notice that the hour 02:00 a.m doesn't exist, instead advancing automatically to 03:00 a.m.<br>
Furthermore, do note that getOffset() returns different times, as the relative hour to GMT changes as well, as the hour change happens at different times around the world.<br>Here is how moving backwards translates into JAVA:<br>var date = LocalDate.of(2024, Month.NOVEMBER, 3);
var time = LocalTime.of(1, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2024-­11-­03T01:30-­04:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2024-­11-­03T01:30-­05:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2024-­11-­03T02:30-­05:00[US/Eastern]
Copy<br>You can notice, this time, that we land on the hour 01:30 a.m twice, because we rolled time backwards. Do note the offset change from GMT time.<br>Finally, trying to create a time that doesn't exist only moves the clock forward to make up for the inaccuracy:<br>var date = LocalDate.of(2024, Month.MARCH, 10);
var time = LocalTime.of(2, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime);
// 2024–03–10T03:30–04:00[US/Eastern]
Copy<br>Java switched automatically the time from 02:30 a.m to 03:30 a.m to make up for the incorrect hour.<br><br>In the exam, you have to be able to:<br>
<br>Be able to determine the output of a code using String. See more in <a data-href="#Creating and manipulating strings" href="about:blank#Creating_and_manipulating_strings" class="internal-link" target="_self" rel="noopener">Creating and manipulating strings</a>.
<br>Be able to determine the output of a code using StringBuilder. See more in <a data-href="#Using the *StringBuilder* class" href="about:blank#Using_the_*StringBuilder*_class" class="internal-link" target="_self" rel="noopener">Using the *StringBuilder* class</a>.
<br>Understand the difference between ==&nbsp;and equals(). See more in <a data-href="#Understanding Equality" href="about:blank#Understanding_Equality" class="internal-link" target="_self" rel="noopener">Understanding Equality</a>.
<br>Be able to determine the output of a code using arrays. See more in <a data-href="#Understanding arrays" href="about:blank#Understanding_arrays" class="internal-link" target="_self" rel="noopener">Understanding arrays</a>.
<br>Identify the return types of Math methods. See more in <a data-href="#Calculating with *Math API*" href="about:blank#Calculating_with_*Math_API*" class="internal-link" target="_self" rel="noopener">Calculating with *Math API*</a>.
<br>Recognize invalid uses of dates and times. See more in <a data-href="#Working with dates and times" href="about:blank#Working_with_dates_and_times" class="internal-link" target="_self" rel="noopener">Working with dates and times</a>.
<br>]]></description><link>ocp/chapter-4-core-apis.html</link><guid isPermaLink="false">OCP/CHAPTER 4 - CORE APIS.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Wed, 03 Jul 2024 14:13:03 GMT</pubDate><enclosure url="blob:app://obsidian.md/05e427d2-b375-40a9-9cbc-d2dd71af91a8" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="blob:app://obsidian.md/05e427d2-b375-40a9-9cbc-d2dd71af91a8"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter 2]]></title><description><![CDATA[ 
 <br><br><br><br>In the following snippet, there are three names you should know:<br>var c = a + b;
Copy<br>There are:<br>
<br>Operands, which are a and b.
<br>Operators, which is the +.
<br>Results, which is the c.
<br><br>Like in mathematics, some operators take precedence over others, below is a table the list the priority of operations (from top to bottom):<br><br>What should I remember ?
You need to remember all of this. However, you will not be tested on some of them, like the shift operator, but it is handy to keep them close to know what they are.
<br>See also...
The arrow operator -&gt; is called the arrow function or lambda operator. You will see more of it in <a data-href="CHAPTER 3 - MAKING DECISIONS" href="ocp/chapter-3-making-decisions.html" class="internal-link" target="_self" rel="noopener">CHAPTER 3 - MAKING DECISIONS</a> and <a data-href="CHAPTER 8" href="ocp/chapter-8.html" class="internal-link" target="_self" rel="noopener">CHAPTER 8</a>.
<br><br>An unary operator is an operator that require exactly one operand or variable.<br>
Here is an exhaustive list of them:<br><br>You will see more casting down in <a data-href="#Assigning values" href="about:blank#Assigning_values" class="internal-link" target="_self" rel="noopener">Assigning values</a>.<br><br>The logical complement operator flips the value of a boolean.<br>
For example:<br>boolean example = false; // example = false
example = !example;
System.out.println(example); // example = true
Copy<br>The bitwise complement operator flips all the 0s and 1s of a number.<br>
For example:<br>int value = 3; // 0011
value = ~value; // 1100
System.out.println(value); // -4
Copy<br>You don't need to know...
You don't need to know the binary arithmetic associated with a bitwise complement. You however need to know that it transforms a number following this rule:
int value = 3;
value = ~value;
// IS EQUAL TO
value = -1 * value - 1
Copy
<br>The negation operator reverses the sign of an expression.<br>
For example:<br>int value = 3; // 3
value = -value;
System.out.println(value); // -3
Copy<br>Tricks ahead!
You cannot apply every operator to every type.<br>
For example:
int a = !5; // DOES NOT COMPILE
boolean b = -true // DOES NOT COMPILE
boolean c = !0 // DOES NOT COMPILE
Copy
This does not work because:

<br>You cannot logically revert a numerical value
<br>You cannot numerically revert a logical value
<br>You cannot assign a numerical value to a boolean value.

The exam will try to trick you into believing that you can assign a 1 to true and a 0 to false, but that isn't possible.
<br><br>There are 4 increment and decrement operators. The following table showcases them all:<br><br>As an example:<br>int example = 0;
example++; // 1
example--; // 0
++example; // 0
--example; // 1
System.out.println(example); // 0
Copy<br>Required Knowledge
You need to know the difference between ++a and a++. There will be multiple questions about this in the exam.
<br>Tricks ahead!
It may be a bit confusing, but you need to know what the following code does:
int a = 0;
a = a++;
System.out.println(a); // 0
Copy
The result may seem counter intuitive, but the operation a++ is completely ignored. This means that a is 0 after the value assignment.
<br><br>The opposite of <a data-href="#Unary operators" href="about:blank#Unary_operators" class="internal-link" target="_self" rel="noopener">Unary operators</a>, as those need two operands to function.<br><br>There are 5 arithmetic operators. Here is a list of them:<br><br>But what about String ?
Only the addition, + and += may be applied to String, resulting in String concatenation.
<br>Parentheses rules
Parentheses are allowed and follow the same principles as in mathematics.<br>
However, you need to be wary of unmatched parentheses:
int a = 1 + (3 * 5; // DOES NOT COMPILE
int b = 2 + 3) * (4; // DOES NOT COMPILE
int c = [1 + 2] // DOES NOT COMPILE
Copy
The first two examples don't have matching parenthesis, which makes the code fail.<br>
The third line also makes the compiler fail, because java doesn't allow brackets to be used in place of parentheses.
<br>Division rules
Division of integer values return the floor value of the division.
<br>You don't need to know...
Modulus operations (%) can also be applied to negative and floating point numbers. However, you don't need to know how to do that for the exam, just know that it's possible.
<br><br>When applying operators to data types, some rules and protocols apply:<br>
<br>If two values have different data types, Java will automatically promote one of the value to the larger of the two data types.
<br>If one of the values is integral and the other is floating-point, java will automatically promote the integral value to the floating point data type.
<br>Smaller data types, such as byte, short, char are promoted to int any time they're used with a java binary arithmetic operator with a variable (not a value!).
<br>After all promotions have occurred and all operands have the same data type, the resulting value will have the same data type as its promoted operands.
<br>Be careful!
The third rule doesn't apply to <a data-tooltip-position="top" aria-label="Unary operators" data-href="#Unary operators" href="about:blank#Unary_operators" class="internal-link" target="_self" rel="noopener">unary operators</a>.
<br>For example:<br>int x = 1;
long y = 33; // larger than int
var z = x * y; // int * long = long

double x = 39.21; // larger than float
float y = 2.1f;
var z = x * y; // double * float = double

short x = 10; // promoted to int
short y = 3; // promoted to int
var z = x * y; // short * short = int

short w = 14; // promoted to int
float x = 13;
double y = 30; // larger than double
var z = w * x / z; // short * float / double = double
Copy<br>Tricks ahead!
Be careful: automatic promotion does not apply when trying to convert to a smaller data type. If you try to do so anyways, a compilation error will occur.
<br><br>Tricks ahead!
Compilation errors from assignment operators (=) are often overlooked, make sure to pay attention to them!
<br><br>The assignment operator, commonly referred to as =, applies the result of the operation on the right side to the left side. A simple example is int example = 1.<br>We will see more in <a data-href="#Compound assignment operators" href="about:blank#Compound_assignment_operators" class="internal-link" target="_self" rel="noopener">Compound assignment operators</a>.<br><br>Casting values is performed as follows:<br>int a = (int) 5; // unnecessary
int b = (short) 2; // int -&gt; short
String c = (String) "bird"; // unnecessary
short d = (short)(4 + 10); // see below
Copy<br>Line 4 is a bit special, as it reminds you of the fact that casting is an <a data-tooltip-position="top" aria-label="Unary operators" data-href="#Unary operators" href="about:blank#Unary_operators" class="internal-link" target="_self" rel="noopener">unary operator</a>. Which means that if there weren't any parentheses, only the 4 would be converted to short.<br>Casting is not only for numeric values, but also for objects. However, no real conversion is done, only the reference to the object is changed.<br>Here are some examples of non-compiling code:<br>int e = 1.0; // DOES NOT COMPILE
short f = 1921222; // DOES NOT COMPILE
int g = 9f; // DOES NOT COMPILE
long h = 192_301_398_193_810_323; // DOES NOT COMPILE
Copy<br>All of these are incorrect declarations, for the good reason that we are not casting any of the values to the right type. int cannot receive decimals, short cannot receive large numbers, int cannot receive float values, and long cannot receive such big numbers.<br>You can fix the previous code by applying casting correctly:<br>int e = (int)1.0;
short f = (short)1921222; // Overflow: stored as 20678
int g = (int)9f;
long h = 192_301_398_193_810_323L;
Copy<br>Be careful!
Pay attention to line 4, as we are not actually casting anything. If he tried:
long h = (long) 192_301_398_193_810_323; // DOES NOT COMPILE
Copy
The program would not compile, because the number is first interpreted as an int by the compiler, and is then out of range.
<br>Tricks ahead!
Exam makers have a trick question they like to pose.<br>
The following operation will not work:
short a = (short) 5 + (short) 6;
Copy
Because both values will be promoted to int as soon as they are added. The only way to make this code work would be to cast the whole operation, like so:
short a = (short) (5 + 6);
Copy
<br>You don't need to know...
Overflow and Underflow are out of scope for the exam.
<br><br>Casting variables is a very delicate operation, which often results in compiler errors.<br>
Here is an example:<br>byte a = 1;
byte b = 100;
short c = 5;
short d = 2 + 1;
short e = 2 + b; // DOES NOT COMPILE
byte f = 7 * 100; // DOES NOT COMPILE
Copy<br>Line 5 does not compile because b is not a value, and the compiler doesn't know if it should promote the variable to an int or not.<br>
Line 6 does not compile because 700 is way too big for a byte, which has a maximum limit of 127.<br><br>There are more assignment operators, which are described in the table below. (Beware as the plain assignment [=] is here as a reminder).<br><br>Compound assignment operators are more than a save of time, they also remove explicit casting.<br>
Here is an example:<br>long a = 10;
int b = 5;
b = b * a; // DOES NOT COMPILE (needs casting to int)
b *= a;
Copy<br>Line 4 is okay, as what it does is casting b to long, multiplying both, and casting the result to b's type, which is an int.<br>
The compiler will automatically cast the result of a compound assignment to the type on the left side of the operator.<br><br>The assignment operator is an operation in and of itself. It can be used multiple times in a single line. The main thing to remember is that *assignment operators are read from right to left*.<br>
For example:<br>long a = 5; // a == 5
long b = (a = 3); // b == a == 3;
Copy<br>This code compiles correctly, and a is assigned the value 3, before being sent to b.<br>Tricks ahead!
The exam makers are fond of tricking people with assignment operators. The main trick they use is the following one:
boolean a = false;
if (a = true) {
	System.out.println("Good!");
}
Copy
The code not only compiles, but it also prints out Good!, because inside the if statement, a is assigned the value true, making the if statement true, thus entering the statement.
<br><br>Aside from operations, another set of operators allows you to compare values.<br><br>The first set of operators are the equal operator and not equal operator.<br>
Here is a table of them:<br><br>These operators can be applied to numeric values, boolean values and objects (including String andnull).<br>
You cannot mix two different types in an equality operation.<br>
For example:<br>boolean a = true == 3; // DOES NOT COMPILE
boolean b = false != "a String"; // DOES NOT COMPILE
boolean c = 10.2 == "another String"; // DOES NOT COMPILE
Copy<br>These assertions do not work, because we try to mix different types when checking for them.<br>Be careful!
For object equality, the rule is slightly changed. The equality operator returns true only if the references to the object point to the same object or null. For example:
var a = new File("file.txt");
var b = new File("file.txt");
var c = b;
System.out.println(a == b); // false
System.out.println(b == c); // true
Copy
a and b both point to objects that have the same content, but in the end, they are different objects. Only b and c point to the same object, because c was copied from b.
<br>Seealso
You will see more about object equality and String equality in <a data-href="CHAPTER 4 - CORE APIS" href="ocp/chapter-4-core-apis.html" class="internal-link" target="_self" rel="noopener">CHAPTER 4 - CORE APIS</a>.
<br><br>Relational operators compare two expressions and either return a true or false booleanvalue.<br>
Here are all the boolean values you need to know for the exam:<br><br><br>The first four operators in the <a data-tooltip-position="top" aria-label="Relational operators" data-href="#Relational operators" href="about:blank#Relational_operators" class="internal-link" target="_self" rel="noopener">table above</a> only apply to numeric values. If the two numeric operands are not of the same data type, standard <a data-href="#Numeric Promotion" href="about:blank#Numeric_Promotion" class="internal-link" target="_self" rel="noopener">Numeric Promotion</a> occurs.<br>For example:<br>int a = 2, b = 4, c = 2;
System.out.println(a &lt; b); // true
System.out.println(a &lt;= b); // true
System.out.println(a &gt;= c); // true
System.out.println(a &gt; c); //false
Copy<br>Notice how the last line is false: this is because the operator is strictly greater than, and a is strictly equal to c.<br><br>The last relational operator shown in the <a data-tooltip-position="top" aria-label="Relational operators" data-href="#Relational operators" href="about:blank#Relational_operators" class="internal-link" target="_self" rel="noopener">table above</a> is the instanceof operator. It is useful to know if an object is of a certain custom type. This is especially important in the cases of polymorphism, as discussed further in <a data-href="CHAPTER 6" href="ocp/chapter-6.html" class="internal-link" target="_self" rel="noopener">CHAPTER 6</a>.<br>For example:<br>Integer a = Integer.valueOf(9);
Number b = a;
Object c = a;
System.out.println(a instanceof Integer); // true
System.out.println(a instanceof Number); // true
System.out.println(a instanceof Object); // true
Copy<br>As shown above, an object can be instances of multiple objects, as long as it inherits from them. This is why a is an instance of Integer, Number and Object at the same time.<br>To go further...
A good practice for later is to call instanceof before casting. For example:
if (a instanceof Integer) {
	Integer b = (Integer) a;
}
Copy
<br>Tricks ahead!
The exam might try to trip you up with incompatible instanceof calls. For example:
Integer a = 0;
if (a instanceof String) { // DOES NOT COMPILE
	System.out.println("Good!");
}
Copy
If the compiler can determine that a variable cannot possibly be cast into another specific class, such as Number to String, it reports an error.
<br>But what about null ?
instanceof on a null variable always returns false. For example:
System.out.println(null instanceof Object); // false
Object a = null;
System.out.println(a instanceof String); // false
Copy
However, having a null on the right side of the instanceof does not compile.<br>
For example:
System.out.println(null instanceof null); // DOES NOT COMPILE
Copy
<br>Seealso
There's a lot more coming on the instanceof operator. You can see more on <a data-href="CHAPTER 3 - MAKING DECISIONS" href="ocp/chapter-3-making-decisions.html" class="internal-link" target="_self" rel="noopener">CHAPTER 3 - MAKING DECISIONS</a>.
<br><br>Logical operators can be applied to both boolean and numeric values. They're referred as logical operators when applied to the former, and bitwise operators to the latter, as they perform logical operations to the bits the compose the number.<br>Here is a table containing all the logical operators:<br><br><br>The Conditional operators are also called short circuit operators, and are nearly identical to the <a data-href="#Logical operators" href="about:blank#Logical_operators" class="internal-link" target="_self" rel="noopener">Logical operators</a>, with the one difference that the program only evaluates the left value if the operation in guaranteed to return a value.<br>
Here is a table of them:<br><br>For example:<br>int a = 10;
boolean b = true || (a &lt; 4);
System.out.println(b); // true
Copy<br>The left side of true || (a &lt; 4) is always true, so the right side of the operator will not be evaluated.<br><br>Conditional operators are used to check for null values too.<br>
For example:<br>if(a != null &amp; a.getNum() &lt; 5) { // This could throw a NullPointerException
	//...
}
if(a != null &amp;&amp; a.getNum() &lt; 5) { // If a is null, the right side will not be evaluated
	//...
}
Copy<br>Using the conditional operators are a good way to check for null when trying to access a value, as they will not try to access it if the check is true.<br><br>Tricks ahead!
Be wary of conditional operators as they are often used to trick you into thinking an operation is being executed, when in reality, it is not. For example:
int a = 6;
boolean b = (a &gt;= 6) || (++a &lt;= 7);
System.out.println(a); // a == 6
Copy
Because (a &gt;= 6), the right side is never evaluated, so the result will be 6.
<br><br>The final operator that is required to know for the exam is the ternary operator, otherwise called conditional operator.<br>
It is written as booleanExpression ? IfTrue : IfFalse.<br>
The booleanExpression must be a boolean expression, while IfTrue and IfFalse have to be expressions that return any value. We will see more about if/else statements later in <a data-href="CHAPTER 3 - MAKING DECISIONS" href="ocp/chapter-3-making-decisions.html" class="internal-link" target="_self" rel="noopener">CHAPTER 3 - MAKING DECISIONS</a>.<br>For example of how a ternary operator works, it usually goes like this:<br>// With standard if / else
int a = 5;
int b;
if (a &lt; 2) {
	b = 3;
} else {
	b = 4;
}
// With a ternary operator
int a = 5;
int b = a &lt; 2 ? 3 : 4;
Copy<br>The two pieces of code are equivalent, but the second one is definitely shorter and easy to read.<br>
Multiple ternary operators can be used together. For example:<br>int a = 5;
int b = a &lt; 4 ? a &gt; 2 ? 3 : 4 : 5;
// It is recommended to use parentheses to separate ternary operators:
int b = (a &lt; 4 ? ((a &gt; 2) ? 3 : 4) : 5);
Copy<br>In the exam...
There is no requirement that the return values of a ternary operator have to be of the same type. For example:
int a = 7;
System.out.print((a &gt; 5) ? 21 : "a string");
int b = (a &lt; 5) ? 3 : "a string"; // DOES NOT COMPILE
Copy
Both expressions return int or String, but the first one is in a println statement that can convert any object into a String, while the second expression tries to assign a String to an int, which the compiler knows that's not possible.
<br><br>In the exam, you have to be able to:<br>
<br>Be able to write code that uses java operators. See more in <a data-href="#Operators" href="about:blank#Operators" class="internal-link" target="_self" rel="noopener">Operators</a>.
<br>Be able to recognize which operators are associated with which data types. See more in <a data-href="#Operators" href="about:blank#Operators" class="internal-link" target="_self" rel="noopener">Operators</a>, <a data-href="#Assigning values" href="about:blank#Assigning_values" class="internal-link" target="_self" rel="noopener">Assigning values</a>, <a data-href="#Comparing values" href="about:blank#Comparing_values" class="internal-link" target="_self" rel="noopener">Comparing values</a> and <a data-href="#Ternary operator" href="about:blank#Ternary_operator" class="internal-link" target="_self" rel="noopener">Ternary operator</a>.
<br>Understand when casting is required or numeric promotion occurs. See more in <a data-href="#Casting values" href="about:blank#Casting_values" class="internal-link" target="_self" rel="noopener">Casting values</a>, <a data-href="#Casting variables" href="about:blank#Casting_variables" class="internal-link" target="_self" rel="noopener">Casting variables</a> and <a data-href="#Numeric Promotion" href="about:blank#Numeric_Promotion" class="internal-link" target="_self" rel="noopener">Numeric Promotion</a>.
<br>Be able to write code that uses parentheses to override operator precedence. See more in <a data-href="#Operator Precedence" href="about:blank#Operator_Precedence" class="internal-link" target="_self" rel="noopener">Operator Precedence</a> and <a data-href="#Arithmetic operators" href="about:blank#Arithmetic_operators" class="internal-link" target="_self" rel="noopener">Arithmetic operators</a>.
<br>]]></description><link>ocp/chapter-2-java-operators.html</link><guid isPermaLink="false">OCP/CHAPTER 2 - JAVA OPERATORS.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Fri, 24 May 2024 13:08:45 GMT</pubDate></item><item><title><![CDATA[CHAPTER 6]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-6.html</link><guid isPermaLink="false">OCP/CHAPTER 6.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 23 Apr 2024 15:51:25 GMT</pubDate></item><item><title><![CDATA[CHAPTER 7]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-7.html</link><guid isPermaLink="false">OCP/CHAPTER 7.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Mon, 06 May 2024 09:26:16 GMT</pubDate></item><item><title><![CDATA[CHAPTER 8]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-8.html</link><guid isPermaLink="false">OCP/CHAPTER 8.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Mon, 29 Apr 2024 08:22:51 GMT</pubDate></item><item><title><![CDATA[CHAPTER 9]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-9.html</link><guid isPermaLink="false">OCP/CHAPTER 9.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 21 May 2024 11:05:30 GMT</pubDate></item><item><title><![CDATA[CHAPTER 10]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-10.html</link><guid isPermaLink="false">OCP/CHAPTER 10.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 21 May 2024 11:05:39 GMT</pubDate></item><item><title><![CDATA[CHAPTER 11]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-11.html</link><guid isPermaLink="false">OCP/CHAPTER 11.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 14 May 2024 07:22:38 GMT</pubDate></item><item><title><![CDATA[CHAPTER 12]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-12.html</link><guid isPermaLink="false">OCP/CHAPTER 12.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Sat, 27 Apr 2024 13:50:13 GMT</pubDate></item><item><title><![CDATA[CHAPTER 13]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-13.html</link><guid isPermaLink="false">OCP/CHAPTER 13.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Mon, 20 May 2024 14:43:30 GMT</pubDate></item><item><title><![CDATA[CHAPTER 15]]></title><description><![CDATA[ 
 ]]></description><link>ocp/chapter-15.html</link><guid isPermaLink="false">OCP/CHAPTER 15.md</guid><dc:creator><![CDATA[Thibaud DANDOY]]></dc:creator><pubDate>Tue, 21 May 2024 11:05:50 GMT</pubDate></item></channel></rss>